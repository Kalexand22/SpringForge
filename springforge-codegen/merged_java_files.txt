
// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\changelog\ChangelogEntry.java

package com.springforge.codegen.changelog;

import java.nio.file.Path;

public class ChangelogEntry {

  private String title;
  private String description;
  private String type;
  private Path path;

  public void setTitle(String title) {
    this.title = title;
  }

  public String getTitle() {
    return title;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public String getDescription() {
    return description;
  }

  public void setType(String type) {
    this.type = type;
  }

  public String getType() {
    return type;
  }

  public void setPath(Path path) {
    this.path = path;
  }

  public Path getPath() {
    return path;
  }

  @Override
  public String toString() {
    return "ChangelogEntry [title=" + getTitle() + ", type=" + getType() + "]";
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\changelog\ChangelogEntryConstants.java

package com.springforge.codegen.changelog;

import java.util.List;

public final class ChangelogEntryConstants {

  private ChangelogEntryConstants() {}

  public static final String CHANGELOG_FILE = "CHANGELOG.md";
  public static final String INPUT_PATH = "changelogs/unreleased";

  public static final List<String> TYPES =
      List.of("Feature", "Change", "Deprecate", "Remove", "Fix", "Security");

  public static final boolean ALLOW_NO_ENTRY = false;
  public static final String DEFAULT_CONTENT = "";
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\changelog\ChangelogEntryParser.java

package com.springforge.codegen.changelog;

import com.springforge.common.ObjectUtils;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Map;
import org.yaml.snakeyaml.LoaderOptions;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.constructor.SafeConstructor;

public class ChangelogEntryParser {

  public ChangelogEntry parse(File file) throws IOException {
    Map<String, Object> values = loadYaml(file);
    if (ObjectUtils.isEmpty(values)) {
      throw new IllegalStateException(file + " content is empty");
    }
    return createEntry(values, file);
  }

  private Map<String, Object> loadYaml(File file) throws IOException {
    Yaml yaml = new Yaml(new SafeConstructor(new LoaderOptions()));
    try (InputStream ios = new FileInputStream(file)) {
      return yaml.load(ios);
    }
  }

  private ChangelogEntry createEntry(Map<String, Object> entries, File file) {
    ChangelogEntry changelogEntry = new ChangelogEntry();
    for (Map.Entry<String, Object> item : entries.entrySet()) {
      String value = item.getValue().toString();
      if (value == null) continue;
      if ("title".equalsIgnoreCase(item.getKey())) {
        changelogEntry.setTitle(value.trim());
      } else if ("description".equalsIgnoreCase(item.getKey())) {
        changelogEntry.setDescription(value.trim());
      } else if ("type".equalsIgnoreCase(item.getKey())) {
        changelogEntry.setType(value);
      }
    }
    changelogEntry.setPath(file.toPath());
    return changelogEntry;
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\changelog\Release.java

package com.springforge.codegen.changelog;

import java.util.List;
import java.util.Map;

public class Release {

  private String version;
  private String header;
  private String defaultContent;
  private Map<String, List<ChangelogEntry>> entries;

  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }

  public String getHeader() {
    return header;
  }

  public void setHeader(String header) {
    this.header = header;
  }

  public Map<String, List<ChangelogEntry>> getEntries() {
    return entries;
  }

  public void setEntries(Map<String, List<ChangelogEntry>> entries) {
    this.entries = entries;
  }

  public void setDefaultContent(String defaultContent) {
    this.defaultContent = defaultContent;
  }

  public String getDefaultContent() {
    return defaultContent;
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\changelog\ReleaseGenerator.java

package com.springforge.codegen.changelog;

import com.springforge.common.ObjectUtils;
import com.springforge.common.StringUtils;
import com.google.common.base.Strings;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class ReleaseGenerator {

  private static final String NEW_LINE = System.lineSeparator();

  public String generate(Release release) {
    StringBuilder releaseContent = new StringBuilder();

    appendHeader(releaseContent, release);
    appendEntries(releaseContent, release);
    if (ObjectUtils.isEmpty(release.getEntries())) {
      if (ObjectUtils.notEmpty(release.getDefaultContent())) {
        if (!endWithEmptyLine(releaseContent.toString())) {
          releaseContent.append(NEW_LINE);
        }
        releaseContent.append(release.getDefaultContent()).append(NEW_LINE);
      }
    }

    return releaseContent.toString();
  }

  private void appendEntries(StringBuilder content, Release release) {
    if (release.getEntries() == null) {
      return;
    }

    for (String type : release.getEntries().keySet()) {
      appendEntriesPerType(content, type, release.getEntries().get(type));
    }
  }

  private void appendEntriesPerType(
      StringBuilder content, String type, List<ChangelogEntry> entries) {
    if (entries == null || entries.isEmpty()) {
      return;
    }
    if (!endWithEmptyLine(content.toString())) {
      content.append(NEW_LINE);
    }
    content.append("#### ").append(type).append(NEW_LINE).append(NEW_LINE);
    for (ChangelogEntry entry : entries) {
      content.append(MessageFormat.format("* {0}", entry.getTitle()));
      if (!StringUtils.isEmpty(entry.getDescription())) {
        content
            .append(NEW_LINE)
            .append(NEW_LINE)
            .append(new EntryDescriptionGenerator(entry.getDescription()).generate());
      }
      content.append(NEW_LINE);
    }
  }

  private boolean endWithEmptyLine(String content) {
    return NEW_LINE.equals(Character.toString(content.charAt(content.length() - 1)))
        && NEW_LINE.equals(Character.toString(content.charAt(content.length() - 2)));
  }

  private void appendHeader(StringBuilder content, Release release) {
    content
        .append(MessageFormat.format("## {0}", release.getHeader()))
        .append(NEW_LINE)
        .append(NEW_LINE);
  }

  static class EntryDescriptionGenerator {

    private final String content;

    public EntryDescriptionGenerator(String content) {
      this.content = content;
    }

    public String generate() {
      List<String> lines = new ArrayList<>();
      lines.add("<details>");
      lines.add("");
      for (String line : content.trim().split(NEW_LINE)) {
        lines.add(StringUtils.isBlank(line) ? "" : line);
      }
      lines.add("");
      lines.add("</details>");
      return indent(String.join(NEW_LINE, lines), 2);
    }

    private String indent(String text, int n) {
      if (ObjectUtils.isEmpty(text)) {
        return "";
      }
      Stream<String> stream = Arrays.stream(text.split(NEW_LINE));
      if (n > 0) {
        final String spaces = Strings.repeat(" ", n);
        stream = stream.map(s -> spaces + s);
      }
      return stream.collect(Collectors.joining(NEW_LINE, "", NEW_LINE));
    }
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\changelog\ReleaseProcessor.java

package com.springforge.codegen.changelog;

import java.util.Collection;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;

public class ReleaseProcessor {

  public Release process(
      Collection<ChangelogEntry> changelogEntries,
      String version,
      String header,
      List<String> types,
      String defaultContent) {

    Objects.requireNonNull(version);
    Objects.requireNonNull(header);
    Objects.requireNonNull(changelogEntries);

    validate(changelogEntries);
    adjustEntriesTypes(changelogEntries, types);

    Release release = new Release();
    release.setVersion(version);
    release.setHeader(header);
    release.setDefaultContent(defaultContent);

    LinkedHashMap<String, List<ChangelogEntry>> entriesGroupedByType =
        changelogEntries.stream()
            .sorted(Comparator.comparingInt(e -> types.indexOf(e.getType())))
            .collect(
                Collectors.groupingBy(
                    ChangelogEntry::getType, LinkedHashMap::new, Collectors.toList()));
    release.setEntries(entriesGroupedByType);

    return release;
  }

  private void adjustEntriesTypes(Collection<ChangelogEntry> changelogEntries, List<String> types) {
    for (ChangelogEntry changelogEntry : changelogEntries) {
      changelogEntry.setType(getTargetType(changelogEntry.getType(), types));
    }
  }

  private String getTargetType(String type, List<String> types) {
    for (String targetType : types) {
      if (type.equalsIgnoreCase(targetType)) {
        return targetType;
      }
    }
    throw new IllegalArgumentException(
        String.format("Type %s cannot be found in %s", type, String.join(",", types)));
  }

  private void validate(Collection<ChangelogEntry> changelogEntries) {
    Objects.requireNonNull(changelogEntries);

    Optional<ChangelogEntry> entryWithNullType =
        changelogEntries.stream().filter(entry -> entry.getType() == null).findFirst();
    if (entryWithNullType.isPresent()) {
      throw new IllegalArgumentException(
          "Type cannot be null in changelog entry: " + entryWithNullType.get());
    }

    Optional<ChangelogEntry> entryWithNullTitle =
        changelogEntries.stream().filter(entry -> entry.getTitle() == null).findFirst();
    if (entryWithNullTitle.isPresent()) {
      throw new IllegalArgumentException(
          "Title cannot be null in changelog entry: " + entryWithNullTitle.get());
    }
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\JavaAnnotable.java

package com.springforge.codegen.code;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.IntStream;

public abstract class JavaAnnotable<T extends JavaAnnotable<T>> implements JavaElement {

  private List<JavaAnnotation> annotations = new ArrayList<>();

  private JavaDoc doc;

  private int modifiers;

  private final String name;

  private final String type;

  public JavaAnnotable(String name, String type, int... modifiers) {
    this.name = name;
    this.type = type;
    this.modifiers = IntStream.of(modifiers).reduce(0, (x, y) -> x | y);
  }

  @SuppressWarnings("unchecked")
  protected T self() {
    return (T) this;
  }

  public String getName() {
    return name;
  }

  public String getType() {
    return type;
  }

  public int getModifiers() {
    return modifiers;
  }

  public List<JavaAnnotation> getAnnotations() {
    return annotations;
  }

  /**
   * Set java doc.
   *
   * @param doc the javadoc
   * @return self
   */
  public T doc(JavaDoc doc) {
    this.doc = doc;
    return self();
  }

  /**
   * Add annotation.
   *
   * @param annotation the annotation to add
   * @return self
   */
  public T annotation(JavaAnnotation annotation) {
    this.annotations.add(annotation);
    return self();
  }

  /**
   * Set new modifiers.
   *
   * @param modifiers the modifiers to set
   * @return self
   */
  public T modifiers(int... modifiers) {
    this.modifiers = IntStream.of(modifiers).reduce(0, (x, y) -> x | y);
    return self();
  }

  protected void emitAnnotations(JavaWriter writer) {
    annotations.forEach(a -> writer.emit(a).newLine());
  }

  protected void emitModifiers(JavaWriter writer) {
    if (modifiers > 0) {
      writer.emit(modifiers).emit(" ");
    }
  }

  @Override
  public void emit(JavaWriter writer) {
    if (doc != null) {
      writer.emit(doc);
    }

    emitAnnotations(writer);
    emitModifiers(writer);

    if (type != null) {
      writer.emit(writer.importType(type)).emit(" ");
    }

    writer.emit(name);
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\JavaAnnotation.java

package com.springforge.codegen.code;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.function.Function;
import java.util.stream.Collectors;

/** This class can be used to define annotations. */
public class JavaAnnotation implements JavaElement {

  private String name;

  private Map<String, List<JavaElement>> params = new LinkedHashMap<>();

  /**
   * Create new instance of {@link JavaAnnotation}.
   *
   * @param name fully qualified name of the annotation
   */
  public JavaAnnotation(String name) {
    this.name = name;
  }

  public String getName() {
    return name;
  }

  public JavaAnnotation param(String name, String format, Object... params) {
    if (format == null) {
      return this;
    }
    return param(name, new JavaCode(format, params));
  }

  public JavaAnnotation param(String name, JavaCode... value) {
    return param(name, Arrays.asList(value), x -> x);
  }

  public JavaAnnotation param(String name, JavaAnnotation... value) {
    return param(name, Arrays.asList(value), x -> x);
  }

  public JavaAnnotation param(String name, JavaParam value) {
    return null;
  }

  public <T> JavaAnnotation param(
      String name, Collection<T> value, Function<T, JavaElement> mapper) {
    if (value == null) {
      return this;
    }

    List<JavaElement> values =
        value.stream().map(mapper::apply).filter(Objects::nonNull).collect(Collectors.toList());

    if (values.isEmpty()) {
      return this;
    }

    params.computeIfAbsent(name, key -> new ArrayList<>()).addAll(values);

    return this;
  }

  private void emit(JavaWriter writer, List<JavaElement> values) {
    boolean block = values.size() > 1;

    if (block) {
      writer.emit("{").newLine().indent();
    }

    Iterator<JavaElement> iter = values.iterator();
    if (iter.hasNext()) {
      iter.next().emit(writer);
      iter.forEachRemaining(
          next -> {
            writer.emit(",");
            if (block) {
              writer.newLine();
            }
            next.emit(writer);
          });
    }

    if (block) {
      writer.newLine().unindent().emit("}");
    }
  }

  @Override
  public void emit(JavaWriter writer) {
    writer.emit("@").emit(writer.importType(name));
    if (params.isEmpty()) {
      return;
    }

    if (params.size() == 1 && params.containsKey("value")) {
      writer.emit("(");
      emit(writer, params.get("value"));
      writer.emit(")");
      return;
    }

    Iterator<Map.Entry<String, List<JavaElement>>> iter = params.entrySet().iterator();
    if (iter.hasNext()) {
      writer.emit("(").newLine().indent();
      Map.Entry<String, List<JavaElement>> first = iter.next();
      writer.emit(first.getKey()).emit(" = ");
      emit(writer, first.getValue());
      iter.forEachRemaining(
          next -> {
            writer.emit(",").newLine();
            writer.emit(next.getKey()).emit(" = ");
            emit(writer, next.getValue());
          });
      writer.newLine().unindent().emit(")");
    }
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\JavaCode.java

package com.springforge.codegen.code;

import com.springforge.common.ObjectUtils;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.regex.MatchResult;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/** This class is used to define java code. */
public class JavaCode implements JavaElement {

  private static final Pattern REPLACE_PATTERN = Pattern.compile("\\{(\\d+):(\\w)\\}");

  private final List<String> format = new ArrayList<>();

  private final List<Object[]> params = new ArrayList<>();

  /**
   * Create a new instance of {@link JavaCode}.
   *
   * <p>The format string accepts special positional placeholders to substitute with the given
   * params.
   *
   * <p>For example:
   *
   * <pre>
   * new JavaCode("private {0:t}<String> name = {0:t}.of({1:s}, {2:s});", "java.util.List", "Hello", "World");
   * </pre>
   *
   * This will output:
   *
   * <pre>
   * private List<String> name = List.of("Hello", "World");
   * </pre>
   *
   * Following placeholder suffixes are supported:
   *
   * <ul>
   *   <li><code>t</code> - for type, try to import it
   *   <li><code>s</code> - for string, quote it
   *   <li><code>m</code> - for member, try to import the class and emit SimpleName.member
   *   <li><code>M</code> - for member, try to static import it
   *   <li><code>l</code> - for literal
   * </ul>
   *
   * @param format the code string with positional placeholders
   * @param params the substitution parameters
   */
  public JavaCode(String format, Object... params) {
    next(format, params);
  }

  /**
   * Add next statement.
   *
   * @param format the code string with positional placeholders
   * @param params the substitution parameters
   * @return self
   */
  public JavaCode next(String format, Object... params) {
    this.format.add(format);
    this.params.add(params);
    return this;
  }

  private String replace(JavaWriter writer, Object[] params, MatchResult match) {
    int pos = Integer.valueOf(match.group(1));
    if (pos > params.length - 1) {
      return match.group();
    }
    String kind = match.group(2);
    Object param = params[pos];
    switch (kind) {
      case "t":
        return type(writer, param);
      case "m":
        return member(writer, param);
      case "M":
        return staticMember(writer, param);
      case "s":
        return text(writer, param);
      case "l":
        return text(param);
      case "a":
        return array(param);
      default:
        return match.group();
    }
  }

  private String text(Object value) {
    return String.valueOf(value);
  }

  private String array(Object value) {
    List<String> items =
        ObjectUtils.notEmpty(value)
            ? Arrays.asList(text(value).split("\\s*,\\s*"))
            : Collections.emptyList();
    return '{'
        + items.stream().map(item -> '"' + item + '"').collect(Collectors.joining(", "))
        + '}';
  }

  private String type(JavaWriter writer, Object value) {
    return writer.importType(text(value));
  }

  private String member(JavaWriter writer, Object value) {
    String fqn = text(value);
    if (fqn == null || fqn.isBlank() || fqn.indexOf('.') == -1) {
      return fqn;
    }

    String full = fqn.substring(0, fqn.lastIndexOf('.'));
    String name = fqn.substring(full.length());
    String type = writer.importType(full);

    return type + name;
  }

  private String staticMember(JavaWriter writer, Object value) {
    String fqn = text(value);
    if (fqn == null || fqn.isBlank() || fqn.indexOf('.') == -1) {
      return fqn;
    }
    return writer.importStatic(fqn);
  }

  private String text(JavaWriter writer, Object value) {
    if (value == null) {
      return "";
    }
    return '"' + text(value) + '"';
  }

  @Override
  public void emit(JavaWriter writer) {
    for (int i = 0; i < format.size(); i++) {
      String format = this.format.get(i);
      Object[] params = this.params.get(i);
      Matcher matcher = REPLACE_PATTERN.matcher(format);
      try {
        String code = matcher.replaceAll(m -> this.replace(writer, params, m));
        writer.emit(code);
      } catch (NullPointerException e) {
        matcher.replaceAll(m -> this.replace(writer, params, m));
        throw new RuntimeException(e);
      }
    }
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\JavaCodeUtils.java

package com.springforge.codegen.code;

import com.springforge.common.StringUtils;

public interface JavaCodeUtils {

  static String firstUpper(String name) {
    if (name.length() > 1 && Character.isUpperCase(name.charAt(1))) {
      return name;
    }
    return name.substring(0, 1).toUpperCase() + name.substring(1);
  }

  static String firstLower(String string) {
    if (string.length() > 1 && Character.isUpperCase(string.charAt(1))) {
      return string;
    }
    return string.substring(0, 1).toLowerCase() + string.substring(1);
  }

  static String methodName(String prefix, String field) {
    return prefix + JavaCodeUtils.firstUpper(field);
  }

  static String getterName(String name, boolean isBoolean) {
    return isBoolean ? methodName("is", name) : methodName("get", name);
  }

  static String getterName(String name) {
    return getterName(name, false);
  }

  static String setterName(String name) {
    return methodName("set", name);
  }

  static String stripIndent(CharSequence code) {
    return StringUtils.stripIndent(code);
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\JavaContext.java

package com.springforge.codegen.code;

import static java.util.stream.Collectors.toList;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/** This class manages import statements in the context of given package name. */
public class JavaContext implements JavaElement {

  private static final Pattern NAME_PATTERN =
      Pattern.compile(
          "(\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*\\.)+\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*");

  private String packageName;

  private List<String> wildStatics = new ArrayList<>();

  private List<String> wildImports = new ArrayList<>();

  private Map<String, String> statics = new HashMap<>();

  private Map<String, String> imports = new HashMap<>();

  /**
   * Create a new instance for the given package name.
   *
   * <p>All direct imports under the give package name will be ignored.
   *
   * @param packageName the package name
   */
  public JavaContext(String packageName) {
    this.packageName = packageName;
  }

  /**
   * Get package name of the current import context.
   *
   * @return the package name
   */
  public String getPackageName() {
    return packageName;
  }

  /**
   * Try static import of the given fully qualified name.
   *
   * @param name the static name to import
   * @return this
   */
  public String importStatic(String name) {
    return notWildThen(name, s -> importSingle(s, statics));
  }

  /**
   * Try importing the given fully qualified name.
   *
   * @param type the name to import
   * @return this
   */
  public String importType(String type) {
    return notWildThen(
        type, s -> NAME_PATTERN.matcher(s).replaceAll(m -> importSingle(m.group(), imports)));
  }

  /**
   * Add a wildcard static import.
   *
   * @param wild the wild card
   */
  public void importStaticWild(String wild) {
    String name = wild.trim();
    if (name.endsWith(";")) name = name.substring(0, name.length() - 1);
    if (name.endsWith(".*")) name = name.substring(0, name.length() - 2);
    this.wildStatics.add(name);
  }

  /**
   * Add a wildcard import.
   *
   * @param wild the wild card
   */
  public void importWild(String wild) {
    String name = wild.trim();
    if (name.endsWith(";")) name = name.substring(0, name.length() - 1);
    if (name.endsWith(".*")) name = name.substring(0, name.length() - 2);
    this.wildImports.add(name);
  }

  private List<String> getStaticStatements() {
    return statics.values().stream()
        .filter(s -> shouldImportStatic(s))
        .map(s -> String.format("import static %s;", s))
        .collect(toList());
  }

  private List<String> getImportStatements() {
    return imports.values().stream()
        .filter(s -> shouldImport(s))
        .map(s -> String.format("import %s;", s))
        .collect(toList());
  }

  private String notWildThen(String fqn, Function<String, String> map) {
    if (fqn == null) return null;
    if (fqn.endsWith(".*")) {
      throw new IllegalArgumentException("can't handle wildcard import");
    }
    return map.apply(fqn);
  }

  private String importSingle(String fqn, Map<String, String> imports) {
    final String[] parts = fqn.split("\\.");
    final String name = parts[parts.length - 1];
    if (parts.length == 1) {
      return fqn;
    }
    imports.putIfAbsent(name, fqn);
    return fqn.equals(imports.get(name)) ? name : fqn;
  }

  private boolean shouldImportStatic(String type) {
    String pkg = type.substring(0, type.lastIndexOf('.'));
    return !wildStatics.contains(pkg);
  }

  private boolean shouldImport(String type) {
    String pkg = type.substring(0, type.lastIndexOf('.'));
    return !pkg.equals("java.lang") && !pkg.equals(packageName) && !wildImports.contains(pkg);
  }

  private List<String> sortImports(List<String> imports) {
    return imports.stream().distinct().sorted().collect(Collectors.toList());
  }

  @Override
  public void emit(JavaWriter writer) {
    writer.emit("package ").emit(packageName).emit(";").newLine(2);

    List<String> statics = sortImports(getStaticStatements());
    List<String> imports = sortImports(getImportStatements());

    if (!wildStatics.isEmpty()) {
      sortImports(wildStatics).forEach(s -> writer.emit("import static " + s + ".*;").newLine());
      writer.newLine();
    }

    if (!wildImports.isEmpty()) {
      sortImports(wildImports).forEach(s -> writer.emit("import " + s + ".*;").newLine());
      writer.newLine();
    }

    if (!statics.isEmpty()) {
      statics.forEach(s -> writer.emit(s).newLine());
      writer.newLine();
    }

    if (!imports.isEmpty()) {
      imports.forEach(s -> writer.emit(s).newLine());
      writer.newLine();
    }
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\JavaDoc.java

package com.springforge.codegen.code;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/** This class can be used to define java doc for a java construct. */
public class JavaDoc implements JavaElement {

  private List<JavaCode> lines = new ArrayList<>();

  private Map<String, JavaCode> params = new LinkedHashMap<>();

  private List<JavaCode> exceptions = new ArrayList<>();

  private JavaCode returns;

  /**
   * Create a new instance of the {@link JavaDoc} with the given subject line.
   *
   * @param format the doc subject line as {@link JavaCode} format
   * @param params the code format params
   */
  public JavaDoc(String format, Object... params) {
    this.line(format, params);
  }

  /**
   * Add a line to the doc.
   *
   * @param format the doc subject line as {@link JavaCode} format
   * @param params the code format params
   * @return self
   */
  public JavaDoc line(String format, Object... params) {
    this.lines.add(new JavaCode(format, params));
    return this;
  }

  /**
   * Add a <code>@param</code> tag.
   *
   * @param name the name of the param
   * @param format the doc subject line as {@link JavaCode} format
   * @param params the code format params
   * @return self
   */
  public JavaDoc param(String name, String format, Object... params) {
    this.params.put(name, new JavaCode(format, params));
    return this;
  }

  /**
   * Add an exception to the doc.
   *
   * @param type the exception type name
   * @return self
   */
  public JavaDoc exception(String type) {
    this.exceptions.add(new JavaCode("{0:t}", type));
    return this;
  }

  /**
   * Add <code>@return</code> clause.
   *
   * @param format the doc subject line as {@link JavaCode} format
   * @param params the code format params
   * @return self
   */
  public JavaDoc returns(String format, Object... params) {
    this.returns = new JavaCode(format, params);
    return this;
  }

  @Override
  public void emit(JavaWriter writer) {
    writer.emit("/**").newLine();

    Iterator<JavaCode> iter = lines.iterator();
    if (iter.hasNext()) {
      writer.emit(" * ").emit(iter.next()).newLine();
      if (iter.hasNext()) {
        writer.emit(" *").newLine();
      }
      iter.forEachRemaining(code -> writer.emit(" * ").emit(code).newLine());
    }

    if (!params.isEmpty()) {
      writer.emit(" *").newLine();
      for (Map.Entry<String, JavaCode> item : params.entrySet()) {
        writer.emit(" * @param ").emit(item.getKey()).emit(" ").emit(item.getValue()).newLine();
      }
    }

    if (!exceptions.isEmpty()) {
      writer.emit(" *").newLine();
      exceptions.forEach(code -> writer.emit(" * @throws ").emit(code).newLine());
    }

    if (returns != null) {
      writer.emit(" *").newLine();
      writer.emit(" * @return ").emit(returns).newLine();
    }

    writer.emit(" */").newLine();
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\JavaElement.java

package com.springforge.codegen.code;

/** Interface for all code elements that can emit some code. */
public interface JavaElement {

  /**
   * Emit the code.
   *
   * @param writer the pojo writer
   */
  void emit(JavaWriter writer);
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\JavaEnumConstant.java

package com.springforge.codegen.code;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/** This class can be used to define enum constants. */
public class JavaEnumConstant extends JavaAnnotable<JavaEnumConstant> {

  private List<JavaCode> args;

  /**
   * Create a new instance of the {@link JavaEnumConstant}.
   *
   * @param name the constant name
   * @param args the arguments
   */
  public JavaEnumConstant(String name, Object... args) {
    super(name, null);
    this.args = Stream.of(args).map(arg -> new JavaCode("{0:l}", arg)).collect(Collectors.toList());
  }

  /**
   * Add an argument.
   *
   * @param arg the argument
   * @return self
   */
  public JavaEnumConstant arg(JavaCode arg) {
    this.args.add(arg);
    return this;
  }

  @Override
  public void emit(JavaWriter writer) {
    super.emit(writer);

    if (!args.isEmpty()) {
      writer.emit("(");
      writer.emit(args, ", ");
      writer.emit(")");
    }
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\JavaField.java

package com.springforge.codegen.code;

import java.lang.reflect.Modifier;

/** This class can be used to define class fields. */
public class JavaField extends JavaAnnotable<JavaField> {

  private JavaCode defaultValue;

  /**
   * Create a new instance of the {@link JavaField} with given name and type.
   *
   * @param name the field name
   * @param type the field type
   * @param modifiers field modifiers
   */
  public JavaField(String name, String type, int... modifiers) {
    super(name, type, modifiers);
  }

  /**
   * Define the default value
   *
   * @param defaultValue the default value code
   * @return self
   */
  public JavaField defaultValue(JavaCode defaultValue) {
    this.defaultValue = defaultValue;
    return this;
  }

  public String getGetterName() {
    return "boolean".equals(getType())
        ? "is" + JavaCodeUtils.firstUpper(getName())
        : "get" + JavaCodeUtils.firstUpper(getName());
  }

  public String getSetterName() {
    return "set" + JavaCodeUtils.firstUpper(getName());
  }

  public JavaMethod getGetterMethod() {
    JavaMethod method = new JavaMethod(getGetterName(), getType(), Modifier.PUBLIC);
    method.code("return {0:l};", getName());
    return method;
  }

  public JavaMethod getSetterMethod() {
    JavaMethod method = new JavaMethod(getSetterName(), "void", Modifier.PUBLIC);
    method.param(getName(), getType());
    method.code("this.{0:l} = {0:l};", getName());
    return method;
  }

  @Override
  public void emit(JavaWriter writer) {
    super.emit(writer);

    if (defaultValue != null) {
      writer.emit(" = ").emit(defaultValue);
    }

    writer.emit(";");
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\JavaFile.java

package com.springforge.codegen.code;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.function.Function;
import java.util.stream.Stream;

/**
 * This class can be used to generate java source files for {@link JavaFile} in some given {@link
 * JavaContext}.
 */
public class JavaFile {

  private JavaType javaType;

  private JavaContext javaContext;

  /**
   * Create a new instance of the {@link JavaFile} with the given context and type.
   *
   * @param javaContext the context
   * @param javaType the type
   */
  public JavaFile(JavaContext javaContext, JavaType javaType) {
    this.javaContext = javaContext;
    this.javaType = javaType;
  }

  /**
   * Create a new instance of the {@link JavaFile} with the given package and type.
   *
   * @param packageName the package name
   * @param javaType the type
   */
  public JavaFile(String packageName, JavaType javaType) {
    this(new JavaContext(packageName), javaType);
  }

  /**
   * Get file path for the given base path.
   *
   * @param base the base directory from where to compute the path
   * @return the file path
   */
  public Path getPath(Path base) {
    String[] dirs = javaContext.getPackageName().split("\\.");
    String name = String.format("%s.java", javaType.getName());
    return Stream.of(dirs).map(Paths::get).reduce(base, Path::resolve).resolve(name);
  }

  /**
   * Write the code to the given output.
   *
   * @param output the output target
   * @throws IOException if there is any error while writing to the output
   */
  public void writeTo(Appendable output) throws IOException {
    writeTo(output, s -> s);
  }

  /**
   * Write the code the given output by applying a custom formatter.
   *
   * @param output the output target
   * @param formatter the formatter
   * @throws IOException if there is any error while writing to the output
   */
  public void writeTo(Appendable output, Function<String, String> formatter) throws IOException {
    JavaWriter writer = new JavaWriter(javaContext, "  ").emit(javaType);
    JavaWriter header = new JavaWriter(javaContext, " ").emit(javaContext);
    output.append(formatter.apply(header.toString() + writer.toString()));
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\JavaMethod.java

package com.springforge.codegen.code;

import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/** This class can be used to define java methods and constructors. */
public class JavaMethod extends JavaAnnotable<JavaMethod> {

  private final List<JavaParam> params = new ArrayList<>();

  private final List<JavaCode> throwables = new ArrayList<>();

  private final List<JavaCode> code = new ArrayList<>();

  private boolean defaultMethod;

  private boolean declaration;

  /**
   * Create a new instance of {@link JavaMethod} with the given name, type and modifiers.
   *
   * @param name name of the method
   * @param type type of the method, pass <code>null</code> for constructor
   * @param modifiers method modifiers
   * @see Modifier
   */
  public JavaMethod(String name, String type, int... modifiers) {
    super(name, type, modifiers);
  }

  /**
   * Add method parameter.
   *
   * @param name the parameter name
   * @param type the parameter type
   * @return self
   */
  public JavaMethod param(String name, String type) {
    this.params.add(new JavaParam(name, type));
    return this;
  }

  /**
   * Add method parameter.
   *
   * @param param the parameter to add
   * @return self
   */
  public JavaMethod param(JavaParam param) {
    this.params.add(param);
    return this;
  }

  /**
   * Add throwables this method can throw.
   *
   * @param type name of the throwable type
   * @return self
   */
  public JavaMethod throwable(String type) {
    this.throwables.add(new JavaCode("{0:t}", type));
    return this;
  }

  /**
   * Set the method as interface default method.
   *
   * @param defaultMethod whether the method is a default method
   * @return self
   */
  public JavaMethod defaultMethod(boolean defaultMethod) {
    this.defaultMethod = defaultMethod;
    return this;
  }

  /**
   * Set the method as declaration only (for interface type).
   *
   * @param declaration whether the method is declaration only
   * @return self
   */
  public JavaMethod declaration(boolean declaration) {
    this.declaration = declaration;
    return this;
  }

  /**
   * Add code for method body.
   *
   * @param code the code
   * @return self
   */
  public JavaMethod code(JavaCode code) {
    this.code.add(code);
    return this;
  }

  /**
   * Add code for method body.
   *
   * @param format the code string
   * @param args arguments for the format specifiers
   * @return self
   */
  public JavaMethod code(String format, Object... args) {
    this.code.add(new JavaCode(format, args));
    return this;
  }

  /**
   * Add code for the method body.
   *
   * @param code the code
   * @return self
   */
  public JavaMethod code(Collection<JavaCode> code) {
    this.code.addAll(code);
    return this;
  }

  @Override
  protected void emitModifiers(JavaWriter writer) {
    super.emitModifiers(writer);
    if (defaultMethod) {
      writer.emit(" default ");
    }
  }

  @Override
  public void emit(JavaWriter writer) {
    super.emit(writer);
    writer.emit("(");

    if (params.stream().anyMatch(p -> !p.getAnnotations().isEmpty())) {
      writer.newLine().indent();
      writer.emit(params, ",\n");
      writer.newLine().unindent();
    } else {
      writer.emit(params, ", ");
    }

    writer.emit(")");

    if (!throwables.isEmpty()) {
      writer.emit(" throws ").emit(throwables, ", ");
    }

    if (Modifier.isAbstract(getModifiers()) || declaration) {
      writer.emit(";").newLine();
      return;
    }

    writer.emit(" {").newLine().indent();
    if (!code.isEmpty()) {
      writer.emit(code, "\n");
      writer.newLine();
    }
    writer.unindent().emit("}").newLine();
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\JavaParam.java

package com.springforge.codegen.code;

import java.lang.reflect.Modifier;

/** This class can be used to define java method params. */
public class JavaParam extends JavaAnnotable<JavaParam> {

  /**
   * Create a new instance of {@link JavaParam}.
   *
   * @param name the parameter name
   * @param type the parameter type
   */
  public JavaParam(String name, String type) {
    super(name, type);
  }

  /**
   * Create a new instance of {@link JavaParam}.
   *
   * @param name the parameter name
   * @param type the parameter type
   * @param isFinal whether the param is final
   */
  public JavaParam(String name, String type, boolean isFinal) {
    super(name, type, Modifier.FINAL);
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\JavaType.java

package com.springforge.codegen.code;

import static java.util.function.Predicate.not;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;

/** This class can be used to define Java class. */
public class JavaType extends JavaAnnotable<JavaType> {

  private static final Pattern IMPORT_STATEMENT_PATTERN =
      Pattern.compile("(import\\s+)(static\\s+)?(.*)");

  private JavaCode superType;

  private final Kind kind;

  private final List<JavaCode> superInterfaces = new ArrayList<>();

  private final List<JavaField> fields = new ArrayList<>();

  private final List<JavaMethod> methods = new ArrayList<>();

  private final List<JavaMethod> constructors = new ArrayList<>();

  private final List<JavaEnumConstant> enumConstants = new ArrayList<>();

  private final List<String> rawImports = new ArrayList<>();

  private final List<String> rawCode = new ArrayList<>();

  private JavaType(String name, Kind kind, int... modifiers) {
    super(name, kind.name().toLowerCase(), modifiers);
    this.kind = kind;
  }

  public static JavaType newInterface(String name, int... modifiers) {
    return new JavaType(name, Kind.INTERFACE, modifiers);
  }

  public static JavaType newClass(String name, int... modifiers) {
    return new JavaType(name, Kind.CLASS, modifiers);
  }

  public static JavaType newEnum(String name, int... modifiers) {
    return new JavaType(name, Kind.ENUM, modifiers);
  }

  /**
   * Set the super class.
   *
   * @param type the super class
   * @return self
   */
  public JavaType superType(String type) {
    this.superType = new JavaCode("{0:t}", type);
    return this;
  }

  /**
   * Add an interface to implement.
   *
   * @param type the interface type
   * @return self
   */
  public JavaType superInterface(String type) {
    this.superInterfaces.add(new JavaCode("{0:t}", type));
    return this;
  }

  /**
   * Add a field.
   *
   * @param name name of the field
   * @param type the type of the field
   * @param modifiers modifiers
   * @return self
   */
  public JavaType field(String name, String type, int... modifiers) {
    return field(new JavaField(name, type, modifiers));
  }

  /**
   * Add a field.
   *
   * @param field the field to add
   * @return self
   */
  public JavaType field(JavaField field) {
    this.fields.add(field);
    return this;
  }

  /**
   * Add an enum constant.
   *
   * @param name the constant to add
   * @param args enum arguments
   * @return self
   */
  public JavaType enumConstant(String name, Object... args) {
    enumConstants.add(new JavaEnumConstant(name, args));
    return this;
  }

  /**
   * Add an enum constant.
   *
   * @param constant the constant to add
   * @return self
   */
  public JavaType enumConstant(JavaEnumConstant constant) {
    enumConstants.add(constant);
    return this;
  }

  /**
   * Add a method.
   *
   * @param method the method to add
   * @return self
   */
  public JavaType method(JavaMethod method) {
    this.methods.add(method);
    return this;
  }

  /**
   * Add a constructor.
   *
   * @param constructor the constructor to add
   * @return self
   */
  public JavaType constructor(JavaMethod constructor) {
    this.constructors.add(constructor);
    return this;
  }

  /**
   * Add raw import statements.
   *
   * @param imports the import statements.
   * @return self
   */
  public JavaType rawImports(String... imports) {
    Collections.addAll(rawImports, imports);
    return this;
  }

  /**
   * Add raw code.
   *
   * @param code the code to add
   * @return self
   */
  public JavaType rawCode(String code) {
    this.rawCode.add(code);
    return this;
  }

  private void processRawImports(JavaWriter writer) {
    rawImports.stream()
        .map(String::trim)
        .map(IMPORT_STATEMENT_PATTERN::matcher)
        .filter(Matcher::matches)
        .forEach(
            matcher -> {
              String s = matcher.group(2);
              String n = matcher.group(3).trim();
              if (n.endsWith(";")) n = n.substring(0, n.length() - 1);
              if (n.endsWith(".*")) {
                if (s == null) writer.importWild(n);
                if (s != null) writer.importStaticWild(n);
              } else {
                if (s == null) writer.importType(n);
                if (s != null) writer.importStatic(n);
              }
            });
  }

  @Override
  public void emit(JavaWriter writer) {
    this.processRawImports(writer);
    super.emit(writer);

    if (superType != null) {
      writer.emit(" extends ").emit(superType);
    }

    if (!superInterfaces.isEmpty()) {
      writer
          .emit(" ")
          .emit(kind == Kind.INTERFACE ? "extends" : "implements")
          .emit(" ")
          .emit(superInterfaces, ", ");
    }

    writer.emit(" {").newLine().indent();

    if (!enumConstants.isEmpty()) {
      writer.emit(enumConstants, ",\n\n");

      if (Stream.of(fields, constructors, methods, rawCode).anyMatch(not(List::isEmpty))) {
        writer.emit(";");
      }

      writer.newLine();
    }

    if (!fields.isEmpty()) {
      writer.newLine();
      writer.emit(fields, "\n\n");
      writer.newLine();
    }

    if (!constructors.isEmpty()) {
      writer.newLine();
      writer.emit(constructors, "\n");
    }

    if (!methods.isEmpty()) {
      writer.newLine();
      writer.emit(methods, "\n");
    }

    // emit raw code
    if (!rawCode.isEmpty()) {
      writer.newLine();
      rawCode.forEach(writer::emit);
      writer.newLine();
    }

    writer.unindent().emit("}").newLine();
  }

  static enum Kind {
    INTERFACE,
    CLASS,
    ENUM;
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\JavaWriter.java

package com.springforge.codegen.code;

import java.lang.reflect.Modifier;
import java.util.Collection;
import java.util.Iterator;

/**
 * This class provides code writing functionality.
 *
 * <p>It provides methods to emit code and automatically handles source code indentation.
 */
public final class JavaWriter {

  private static final String NL = "\n";

  private JavaContext context;

  private StringBuilder content;

  private String indentWith;

  private int indent = 0;

  private boolean newLine;

  /**
   * Create a new instance of {@link JavaWriter} with the given import context and indent string.
   *
   * @param context the import context
   * @param indentWith indent string
   */
  public JavaWriter(JavaContext context, String indentWith) {
    this.context = context;
    this.content = new StringBuilder();
    this.indentWith = indentWith;
  }

  public void importStaticWild(String wild) {
    context.importStaticWild(wild);
  }

  public void importWild(String wild) {
    context.importWild(wild);
  }

  public String importStatic(String name) {
    return context.importStatic(name);
  }

  public String importType(String name) {
    return context.importType(name);
  }

  /**
   * Indent one time.
   *
   * @return self
   */
  public JavaWriter indent() {
    this.indent = Math.max(0, indent + 1);
    return this;
  }

  /**
   * Unindent one time.
   *
   * @return self
   */
  public JavaWriter unindent() {
    this.indent = Math.max(0, indent - 1);
    return this;
  }

  /**
   * Emit a new line.
   *
   * @return self
   */
  public JavaWriter newLine() {
    return newLine(1);
  }

  /**
   * Emit given numbers of new lines.
   *
   * @param n number of new lines
   * @return self
   */
  public JavaWriter newLine(int n) {
    content.append(NL.repeat(n));
    newLine = true;
    return this;
  }

  /**
   * Emit the given modifiers.
   *
   * @param modifiers the modifiers
   * @return self
   */
  public JavaWriter emit(int modifiers) {
    if (modifiers > 0) {
      this.emit(Modifier.toString(modifiers));
    }
    return this;
  }

  /**
   * Emit the given code.
   *
   * @param code the code string
   * @return self
   */
  public JavaWriter emit(String code) {
    if (code == null) {
      return this;
    }

    String lead = indentWith.repeat(indent);
    String[] lines = code.split(NL, -1);

    for (int i = 0; i < lines.length; i++) {
      String line = lines[i];
      if (i > 0) newLine();
      if (line.isEmpty()) {
        continue;
      }
      if (newLine) content.append(lead);
      content.append(line);
      newLine = false;
    }

    return this;
  }

  /**
   * Emit code for the given element.
   *
   * @param element the element to emit
   * @return self
   */
  public JavaWriter emit(JavaElement element) {
    element.emit(this);
    return this;
  }

  /**
   * Emit code for the given elements joined by the given separator.
   *
   * @param elements the elements to emit code for
   * @param separator separator string to join the element code
   * @return self
   */
  public JavaWriter emit(Collection<? extends JavaElement> elements, String separator) {
    if (elements == null) return this;
    Iterator<? extends JavaElement> iter = elements.iterator();
    if (iter.hasNext()) {
      emit(iter.next());
      iter.forEachRemaining(
          element -> {
            emit(separator);
            emit(element);
          });
    }
    return this;
  }

  @Override
  public String toString() {
    return content.toString();
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\encryption\StringEncryption.java

package com.springforge.codegen.encryption;

import com.springforge.common.StringUtils;
import java.util.function.Consumer;
import org.jasypt.encryption.pbe.PBEStringEncryptor;
import org.jasypt.encryption.pbe.StandardPBEStringEncryptor;
import org.jasypt.encryption.pbe.config.SimpleStringPBEConfig;

public class StringEncryption {

  private String password;
  private String algorithm = "PBEWITHHMACSHA512ANDAES_256";
  private String keyObtentionIterations;
  private String providerName;
  private String providerClassName;
  private String saltGeneratorClassname;
  private String ivGeneratorClassname = "org.jasypt.iv.RandomIvGenerator";
  private String stringOutputType;

  private PBEStringEncryptor encryptor;

  public StringEncryption(
      String password,
      String algorithm,
      String keyObtentionIterations,
      String providerName,
      String providerClassName,
      String saltGeneratorClassname,
      String ivGeneratorClassname,
      String stringOutputType) {
    set(this::setPassword, password);
    set(this::setAlgorithm, algorithm);
    set(this::setKeyObtentionIterations, keyObtentionIterations);
    set(this::setProviderName, providerName);
    set(this::setProviderClassName, providerClassName);
    set(this::setSaltGeneratorClassname, saltGeneratorClassname);
    set(this::setIvGeneratorClassname, ivGeneratorClassname);
    set(this::setStringOutputType, stringOutputType);
    encryptor = createEncryptor();
  }

  private void set(Consumer<String> consumer, String value) {
    if (StringUtils.isBlank(value)) {
      return;
    }
    consumer.accept(value);
  }

  public String encrypt(String message) {
    return encryptor.encrypt(message);
  }

  PBEStringEncryptor createEncryptor() {
    StandardPBEStringEncryptor encryptor = new StandardPBEStringEncryptor();
    SimpleStringPBEConfig config = new SimpleStringPBEConfig();
    if (StringUtils.isBlank(this.password)) {
      throw new IllegalStateException("Encryption password is required.");
    }
    config.setPassword(this.password);
    config.setAlgorithm(this.algorithm);
    config.setKeyObtentionIterations(this.keyObtentionIterations);
    config.setProviderName(this.providerName);
    config.setProviderClassName(this.providerClassName);
    config.setSaltGeneratorClassName(this.saltGeneratorClassname);
    config.setIvGeneratorClassName(this.ivGeneratorClassname);
    config.setStringOutputType(this.stringOutputType);
    encryptor.setConfig(config);
    return encryptor;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  public void setAlgorithm(String algorithm) {
    this.algorithm = algorithm;
  }

  public void setKeyObtentionIterations(String keyObtentionIterations) {
    this.keyObtentionIterations = keyObtentionIterations;
  }

  public void setProviderName(String providerName) {
    this.providerName = providerName;
  }

  public void setProviderClassName(String providerClassName) {
    this.providerClassName = providerClassName;
  }

  public void setSaltGeneratorClassname(String saltGeneratorClassname) {
    this.saltGeneratorClassname = saltGeneratorClassname;
  }

  public void setIvGeneratorClassname(String ivGeneratorClassname) {
    this.ivGeneratorClassname = ivGeneratorClassname;
  }

  public void setStringOutputType(String stringOutputType) {
    this.stringOutputType = stringOutputType;
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\i18n\I18nExtractor.java

package com.springforge.codegen.i18n;

import com.springforge.common.Inflector;
import com.springforge.common.StringUtils;
import com.springforge.common.XMLUtils;
import com.springforge.common.csv.CSVFile;
import com.google.common.base.Joiner;
import com.google.common.base.Splitter;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;
import com.google.common.io.CharStreams;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.xml.parsers.SAXParser;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.Attributes;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

public class I18nExtractor {

  private static Logger log = LoggerFactory.getLogger(I18nExtractor.class);

  private static final Pattern PATTERN_XML =
      Pattern.compile("\\\\" + File.separator + "(domains|objects|views)\\\\" + File.separator);
  private static final Pattern PATTERN_I18N =
      Pattern.compile(
          "((\\b_t\\s*\\()|([Ii]18n.get\\s*\\()|(T.apply\\s*\\()|(/\\*\\$\\$\\(\\*/))\\s*");
  private static final Pattern PATTERN_HTML =
      Pattern.compile(
          "((\\{\\{(.*?)\\|\\s*t\\s*\\}\\})|(x-translate.*?\\>(.*?)\\<)|(\\<report-box.*?label=[\"'](.*?)[\"']))");
  private static final Pattern PATTERN_EXCLUDE =
      Pattern.compile("(\\.min\\.)|(main.webapp.lib)|(js.i18n)|(\\.test\\.)");

  private static final Set<String> JS_FILE_EXTENSIONS = Set.of(".js", ".jsx", ".ts", ".tsx");

  private static final Set<String> VIEW_TYPES =
      Sets.newHashSet(
          "form", "grid", "tree", "calendar", "kanban", "cards", "gantt", "chart", "custom");

  private static final Set<String> FIELD_NODES =
      Sets.newHashSet(
          "string",
          "boolean",
          "integer",
          "long",
          "decimal",
          "date",
          "time",
          "datetime",
          "binary",
          "enum",
          "one-to-one",
          "many-to-one",
          "one-to-many",
          "many-to-many");

  private static final Set<String> TEXT_ATTRS =
      Sets.newHashSet(
          "tag",
          "prompt",
          "placeholder",
          "x-true-text",
          "x-false-text",
          "data-description",
          "confirm-btn-title",
          "cancel-btn-title",
          "x-tree-field-title");

  private static final Set<String> TEXT_NODES =
      Sets.newHashSet("option", "message", "static", "help");

  private static class I18nItem {

    private String text;
    private Path file;
    private int line;

    public I18nItem(String text, Path file, int line) {
      this.text = text;
      this.file = file;
      this.line = line;
    }
  }

  private abstract static class I18nTextVisitor extends SimpleFileVisitor<Path> {

    private Path base;

    private String entityName;

    private String viewType;

    public I18nTextVisitor(Path base) {
      this.base = base;
    }

    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
      String name = file.getFileName().toString();
      try {
        if (name.endsWith(".xml")) processXml(file);
        if (name.endsWith(".html")) processHtml(file);
        if (name.endsWith(".jsp")) processHtml(file);
        if (name.endsWith(".jsp")) processJava(file);
        if (name.endsWith(".java")) processJava(file);
        if (name.endsWith(".groovy")) processJava(file);

        if (JS_FILE_EXTENSIONS.stream().anyMatch(name::endsWith)
            && !PATTERN_EXCLUDE.matcher(file.toString()).find()) {
          processJava(file);
          processHtml(file);
        }

      } catch (Exception e) {
        log.error(e.getMessage());
      }
      return FileVisitResult.CONTINUE;
    }

    protected abstract void accept(I18nItem item);

    private void processXml(final Path file) throws Exception {

      boolean isView = file.toString().indexOf("views") > -1;
      if (isView) {
        processHtml(file);
        processJava(file);
      }

      if (!PATTERN_XML.matcher(file.toString()).find()) {
        return;
      }

      log.debug("processing XML for: {}", base.getParent().relativize(file));

      final SAXParser parser = XMLUtils.createSAXParser();
      final DefaultHandler handler =
          new DefaultHandler() {

            private Locator locator;
            private boolean readText = false;
            private StringBuilder readTextLines = new StringBuilder();

            @Override
            public void setDocumentLocator(Locator locator) {
              this.locator = locator;
            }

            @Override
            public void startElement(
                String uri, String localName, String qName, Attributes attributes)
                throws SAXException {

              String name = attributes.getValue("name");
              String title = attributes.getValue("title");
              String help = attributes.getValue("help");
              String message = attributes.getValue("message");
              String error = attributes.getValue("error");

              if ("entity".equals(qName)) {
                entityName = name;
              }
              if (VIEW_TYPES.contains(qName)) {
                viewType = qName;
              }

              if (StringUtils.isBlank(title) && "attribute".equals(qName) && "title".equals(name)) {
                title = attributes.getValue("value");
              }

              if (name != null
                  && StringUtils.isBlank(title)
                  && (FIELD_NODES.contains(qName)
                      || "item".equals(qName)
                      || ("tree".equals(viewType) && "column".equals(qName)))) {
                title = Inflector.getInstance().humanize(name);
              }

              if ("true".equals(help) && entityName != null && name != null) {
                help = "help:" + entityName + "." + name;
              }

              accept(new I18nItem(title, file, locator.getLineNumber()));
              accept(new I18nItem(help, file, locator.getLineNumber()));
              accept(new I18nItem(message, file, locator.getLineNumber()));
              accept(new I18nItem(error, file, locator.getLineNumber()));

              for (String attr : TEXT_ATTRS) {
                if ("tag".equals(attr) && "message".equals(qName)) {
                  continue;
                }
                accept(new I18nItem(attributes.getValue(attr), file, locator.getLineNumber()));
              }

              if (TEXT_NODES.contains(qName)) {
                readText = true;
              }
            }

            @Override
            public void endElement(String uri, String localName, String qName) throws SAXException {
              if (TEXT_NODES.contains(qName)) {
                String text = StringUtils.stripIndent(readTextLines.toString());
                accept(new I18nItem(text, file, locator.getLineNumber()));
                readText = false;
                readTextLines.setLength(0);
              }
              if ("entity".equals(qName)) {
                entityName = null;
              }
              if (VIEW_TYPES.contains(qName)) {
                viewType = null;
              }
            }

            @Override
            public void characters(char[] ch, int start, int length) throws SAXException {
              if (readText) {
                readTextLines.append(new String(ch, start, length));
              }
            }
          };

      parser.parse(file.toFile(), handler);
    }

    private void processHtml(Path file) throws Exception {

      String source = null;
      try (Reader reader = new FileReader(file.toFile())) {
        source = CharStreams.toString(reader);
      } catch (IOException e) {
        throw e;
      }

      log.debug("processing HTML for: {}", base.getParent().relativize(file));

      Matcher matcher = PATTERN_HTML.matcher(source);
      while (matcher.find()) {
        int line = getLine(source, matcher.end());
        String text = matcher.group(3);
        if (text == null) {
          text = matcher.group(5);
        }
        if (text == null) {
          text = matcher.group(7);
        }
        text = text.trim();
        if (text.startsWith("\\'") && text.endsWith("\\'")) {
          text = text.substring(2, text.length() - 2);
        } else if (text.startsWith("\\\"") && text.endsWith("\\\"")) {
          text = text.substring(2, text.length() - 2);
        }
        consumePlain(text, file, line);
        matcher.region(matcher.end(), source.length());
      }
    }

    private int consumePlain(String text, Path file, int line) {
      String str = text.trim();
      if (str.indexOf('\'') == 0 || str.indexOf('"') == 0) {
        str = str.substring(1, str.length() - 1);
      }
      accept(new I18nItem(str, file, line));
      return text.length();
    }

    private int consume(String source, Path file, int line) {

      char first = source.charAt(0);
      if (first != '"' && first != '\'') {
        return 0;
      }

      StringBuilder sb = new StringBuilder();

      int i = 1;
      boolean isString = true;

      while (true) {
        char next = source.charAt(i++);
        if (!isString && next == ')') {
          break;
        }
        if (!isString && next == first) {
          isString = true;
          continue;
        }
        if (next == first) {
          isString = source.charAt(i - 2) == '\\';
        }
        if (isString) {
          sb.append(next);
        } else if (next == ',') { // next argument
          accept(new I18nItem(sb.toString(), file, line));
          sb = new StringBuilder();
        }
      }
      accept(new I18nItem(sb.toString(), file, line));
      return i;
    }

    private void processJava(Path file) throws Exception {

      String source = null;
      try (Reader reader = new FileReader(file.toFile())) {
        source = CharStreams.toString(reader);
      } catch (IOException e) {
        throw e;
      }

      log.debug("processing Java for: {}", base.getParent().relativize(file));

      Matcher matcher = PATTERN_I18N.matcher(source);
      while (matcher.find()) {
        int line = getLine(source, matcher.end());
        int end = consume(source.substring(matcher.end()), file, line);
        matcher.region(matcher.end() + end, source.length());
      }
    }

    private int getLine(String source, int index) {
      String sub = source.substring(0, index);
      return Splitter.on('\n').splitToList(sub).size();
    }

    public void walk() {
      try {
        Files.walkFileTree(base, this);
      } catch (IOException e) {
      }
    }
  }

  public void extract(final Path base, boolean update, boolean withContext) {
    Path src = base.resolve(Paths.get("src", "main"));
    Path dest = src.resolve("resources");
    extract(src, dest, update, withContext);
  }

  public void extract(Path srcPath, Path destPath, boolean update, boolean withContext) {
    extract(srcPath, destPath, update, withContext, Collections.emptyList());
  }

  public void extract(
      Path srcPath, Path destPath, boolean update, boolean withContext, List<String> languages) {
    extract(List.of(srcPath), destPath, update, withContext, languages);
  }

  public void extract(
      List<Path> srcPaths,
      Path destPath,
      boolean update,
      boolean withContext,
      List<String> languages) {

    log.info("extracting: {}", "translatable strings...");

    final Multimap<String, String> items = HashMultimap.create();

    for (final Path srcPath : srcPaths) {
      if (Files.notExists(srcPath)) {
        continue;
      }

      final I18nTextVisitor visitor =
          new I18nTextVisitor(srcPath) {

            @Override
            protected void accept(I18nItem item) {
              if (StringUtils.isBlank(item.text)) return;
              String location = null;
              if (item.file != null) {
                location = "" + srcPath.relativize(item.file) + ":" + item.line;
              }
              if (item.text.length() != item.text.trim().length()) {
                log.warn(
                    "Remove leading/trailing white spaces from '{}', of the following text: '{}'",
                    location,
                    item.text);
              }
              items.put(item.text.trim(), location);
            }
          };

      visitor.walk();
    }

    // don't generate empty templates
    if (items.isEmpty()) {
      return;
    }

    List<String> keys = new ArrayList<>(items.keySet());
    List<String[]> values = new ArrayList<>();

    Collections.sort(keys);

    for (String key : keys) {
      String context = "";
      if (withContext) {
        List<String> locations = new ArrayList<>(items.get(key));
        Collections.sort(locations);
        context = Joiner.on('\n').join(locations).trim();
      }
      String[] line = {key, "", "", context};
      values.add(line);
    }

    try {
      update(destPath, values, update, languages);
    } catch (IOException e) {
    }
  }

  private void update(
      Path destPath, final List<String[]> lines, boolean all, List<String> languages)
      throws IOException {

    // first save the template
    Path template = destPath.resolve(Paths.get("i18n", "messages.csv"));

    log.info("generating: " + template);

    save(template, lines);

    if (!all) {
      return;
    }

    // then update all languages
    Files.walkFileTree(
        template.getParent(),
        new SimpleFileVisitor<Path>() {
          @Override
          public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
              throws IOException {
            final String name = file.getFileName().toString();
            final Pattern pattern = Pattern.compile("messages_([a-zA-Z_-]+)\\.csv");
            final Matcher matcher = pattern.matcher(name);
            if (matcher.matches()) {
              log.info("updating: " + file);
              update(file, lines);
            }
            return FileVisitResult.CONTINUE;
          }
        });

    // Generate initial templates for specified languages.
    final List<String> langs =
        Stream.concat(Stream.of("en", "fr"), languages.stream())
            .distinct()
            .collect(Collectors.toUnmodifiableList());

    for (String lang : langs) {
      Path target = template.resolveSibling("messages_" + lang + ".csv");
      if (!Files.exists(target)) {
        log.info("generating: " + target);
        Files.copy(template, target);
      }
    }
  }

  private void update(Path file, List<String[]> lines) throws IOException {
    if (!file.toFile().exists()) return;

    final Map<String, Map<String, String>> values = new HashMap<>();
    final CSVFile csv = CSVFile.DEFAULT.withFirstRecordAsHeader();

    try (CSVParser csvParser = csv.parse(file.toFile())) {
      if (!csvParser.getHeaderNames().contains("key")) {
        throw new IOException("Invalid language file: " + file);
      }
      for (CSVRecord record : csvParser) {
        if (CSVFile.notEmpty(record)) {
          values.put(record.get("key"), record.toMap());
        }
      }
    } catch (IOException e) {
      throw e;
    }

    final List<String[]> myLines = new ArrayList<>();
    for (String[] line : lines) {
      Map<String, String> current = values.get(line[0]);
      String[] copy = line;
      if (current != null) {
        copy = Arrays.copyOf(line, line.length);
        copy[1] = current.get("message");
        copy[2] = current.get("comment");
      }
      myLines.add(copy);
    }

    save(file, myLines);
  }

  private void save(Path file, List<String[]> values) throws IOException {
    Files.createDirectories(file.getParent());
    try (CSVPrinter printer = CSVFile.DEFAULT.withQuoteAll().write(file.toFile())) {
      printer.printRecord("key", "message", "comment", "context");
      for (String[] line : values) {
        for (int i = 0; i < line.length; i++) {
          if (StringUtils.isBlank(line[i])) {
            line[i] = null;
          }
        }
      }
      printer.printRecords(values);
    } catch (IOException e) {
      throw e;
    }
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\EntityGenerator.java

package com.springforge.codegen.code.entity;

import com.springforge.codegen.code.JavaFile;
import com.springforge.codegen.code.JavaType;
import com.springforge.codegen.code.entity.model.BaseType;
import com.springforge.codegen.code.entity.model.Entity;
import com.springforge.codegen.code.entity.model.EnumType;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.Multimap;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Stream;
import jakarta.xml.bind.JAXBException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class EntityGenerator {

  private final Logger log = LoggerFactory.getLogger(getClass());

  private File domainPath;

  private File outputPath;

  private final Set<String> definedEntities = new HashSet<>();
  private final Set<String> definedEnums = new HashSet<>();

  private final List<EntityGenerator> lookup = new ArrayList<>();
  private final Function<String, String> formatter;

  private final Multimap<String, Entity> entities = LinkedHashMultimap.create();
  private final Multimap<String, EnumType> enums = LinkedHashMultimap.create();

  private static final Map<String, Entity> mergedEntities = new HashMap<>();
  private static final Set<String> MODEL_FIELD_NAMES = ImmutableSet.of("archived");
  private static final Set<String> AUDITABLE_MODEL_FIELD_NAMES =
      ImmutableSet.of("createdOn", "updatedOn", "createdBy", "updatedBy");

  public EntityGenerator(File domainPath, File outputPath) {
    this(domainPath, outputPath, String -> String);
  }

  public EntityGenerator(File domainPath, File outputPath, Function<String, String> formatter) {
    this.domainPath = domainPath;
    this.outputPath = outputPath;
    this.formatter = Objects.requireNonNull(formatter);
  }

  private List<File> renderEnum(Collection<EnumType> items, boolean doLookup) throws IOException {

    if (items == null || items.isEmpty()) {
      return null;
    }

    final List<EnumType> all = new ArrayList<>(items);
    final EnumType first = all.get(0);

    final String ns = first.getPackageName();
    final String name = first.getName();

    // prepend all lookup entities
    if (doLookup) {
      for (EntityGenerator gen : lookup) {
        if (gen.definedEnums.contains(name)) {
          if (gen.enums.isEmpty()) {
            gen.processAll(false);
          }
          all.addAll(0, gen.enums.get(name));
        }
      }
    }

    // check that all entities have same namespace
    for (EnumType it : all) {
      if (!ns.equals(it.getPackageName())) {
        throw new IllegalArgumentException(
            String.format(
                "Invalid namespace: %s.%s != %s.%s", ns, name, it.getPackageName(), name));
      }
    }

    final EnumType entity = all.remove(0);

    for (EnumType it : all) {
      entity.merge(it);
    }

    final JavaFile javaFile = new JavaFile(entity.getPackageName(), entity.toJavaClass());

    return List.of(save(javaFile));
  }

  private File save(JavaFile javaFile) throws IOException {
    final File outFile = javaFile.getPath(outputPath.toPath()).toFile();

    Files.createDirectories(outFile.getParentFile().toPath());

    if (outFile.exists()) {
      outFile.delete();
    }

    log.info("Generating: " + outFile);

    writeTo(outFile, javaFile);

    return outFile;
  }

  private List<File> render(Collection<Entity> items, boolean doLookup) throws IOException {

    if (items == null || items.isEmpty()) {
      return null;
    }

    final List<Entity> all = new ArrayList<>(items);
    final Entity first = all.get(0);

    final String ns = first.getPackageName();
    final String name = first.getName();

    // prepend all lookup entities
    if (doLookup) {
      for (EntityGenerator gen : lookup) {
        if (gen.definedEntities.contains(name)) {
          if (gen.entities.isEmpty()) {
            gen.processAll(false);
          }
          all.addAll(0, gen.entities.get(name));
        }
      }
    }

    // check that all entities have same namespace
    for (Entity it : all) {
      if (!ns.equals(it.getPackageName())) {
        throw new IllegalArgumentException(
            String.format(
                "Invalid namespace: %s.%s != %s.%s", ns, name, it.getPackageName(), name));
      }
    }

    final Entity entity = all.remove(0);
    for (Entity it : all) {
      entity.merge(it);
    }
    mergedEntities.put(entity.getName(), entity);

    Optional.ofNullable(entity.getTrack())
        .ifPresent(
            track ->
                track.getFields().stream()
                    .map(field -> field.getName())
                    .filter(fieldName -> !fieldExists(entity.getName(), fieldName))
                    .forEach(
                        fieldName ->
                            log.error("{}: track unknown field: {}", entity.getName(), fieldName)));

    final JavaType javaType = entity.toJavaClass();
    final JavaType repoType = entity.toRepoClass();

    final List<File> rendered = new ArrayList<>();

    if (javaType != null) {
      rendered.add(save(new JavaFile(entity.getPackageName(), javaType)));
    }

    if (repoType != null) {
      rendered.add(save(new JavaFile(entity.getRepoPackage(), repoType)));
    }

    return rendered;
  }

  private boolean fieldExists(String entityName, String fieldName) {
    Entity itEntity;
    String itEntityName = entityName;
    do {
      itEntity = mergedEntities.get(itEntityName);
      if (itEntity == null) {
        if ("AuditableModel".equals(itEntityName)
            && AUDITABLE_MODEL_FIELD_NAMES.contains(fieldName)) {
          return true;
        }
        return MODEL_FIELD_NAMES.contains(fieldName);
      }
      if (itEntity.findField(fieldName) != null) {
        return true;
      }
    } while ((itEntityName = itEntity.getSuperClass()) != null);

    return false;
  }

  protected void writeTo(File output, JavaFile content) throws IOException {
    try (Writer writer = new FileWriter(output, StandardCharsets.UTF_8)) {
      content.writeTo(writer, formatter);
    }
  }

  protected void findFrom(File input) throws IOException {
    final List<BaseType<?>> types;
    try {
      types = EntityParser.parse(input);
    } catch (JAXBException e) {
      throw new RuntimeException(e);
    }

    types.stream()
        .filter(EnumType.class::isInstance)
        .map(BaseType::getName)
        .forEach(definedEnums::add);

    types.stream()
        .filter(Entity.class::isInstance)
        .map(BaseType::getName)
        .forEach(definedEntities::add);
  }

  protected void findAll() throws IOException {
    if (!domainPath.exists()) return;
    for (File file : domainPath.listFiles()) {
      if (file.getName().endsWith(".xml")) {
        findFrom(file);
      }
    }
  }

  protected void process(File input, boolean verbose) throws IOException {
    if (verbose) {
      log.info("Processing: " + input);
    }
    try {
      for (BaseType<?> type : EntityParser.parse(input)) {
        if (type instanceof Entity) entities.put(type.getName(), (Entity) type);
        if (type instanceof EnumType) enums.put(type.getName(), (EnumType) type);
      }
    } catch (JAXBException e) {
      throw new RuntimeException(e);
    }
  }

  protected void processAll(boolean verbose) throws IOException {
    if (!domainPath.exists()) return;
    for (File file : domainPath.listFiles()) {
      if (file.getName().endsWith(".xml")) {
        process(file, verbose);
      }
    }
  }

  private void delete(File file) {
    if (file.isDirectory()) {
      for (File f : file.listFiles()) {
        delete(f);
      }
    }
    file.delete();
  }

  public void addLookupSource(EntityGenerator generator) throws IOException {
    if (generator == null) return;
    if (generator.definedEntities.isEmpty()) {
      generator.findAll();
    }
    lookup.add(0, generator);
  }

  public void clean() {

    if (!this.outputPath.exists()) return;

    log.info("Cleaning generated sources.");
    log.info("Output path: " + outputPath);

    for (File file : outputPath.listFiles()) {
      delete(file);
    }
  }

  public void start() throws IOException {

    log.info("Generating classes...");
    log.info("Domain path: " + domainPath);
    log.info("Output path: " + outputPath);

    outputPath.mkdirs();

    final Set<File> generated = new HashSet<>();

    if (this.domainPath.exists()) {
      for (File file : domainPath.listFiles()) {
        if (file.getName().endsWith(".xml")) {
          process(file, true);
        }
      }
    }

    // generate enums
    for (String name : enums.keySet()) {
      final List<File> rendered = renderEnum(enums.get(name), true);
      if (rendered != null) {
        generated.addAll(rendered);
      }
    }

    // make sure to generate extended enums from parent modules
    final Multimap<String, EnumType> extendedEnums = LinkedHashMultimap.create();
    for (EntityGenerator generator : lookup) {
      for (String name : generator.definedEnums) {
        if (enums.containsKey(name)) {
          continue;
        }
        if (generator.enums.isEmpty()) {
          generator.processAll(false);
        }
        extendedEnums.putAll(name, generator.enums.get(name));
      }
    }
    for (String name : extendedEnums.keySet()) {
      final List<EnumType> all = new ArrayList<>(extendedEnums.get(name));
      if (all == null || all.size() < 2) {
        continue;
      }
      Collections.reverse(all);
      final List<File> rendered = renderEnum(all, false);
      if (rendered != null) {
        generated.addAll(rendered);
      }
    }

    // generate entities
    for (String name : entities.keySet()) {
      final List<File> rendered = render(entities.get(name), true);
      if (rendered != null) {
        generated.addAll(rendered);
      }
    }

    // make sure to generate extended entities from parent modules
    final Multimap<String, Entity> extendedEntities = LinkedHashMultimap.create();
    for (EntityGenerator generator : lookup) {
      for (String name : generator.definedEntities) {
        if (entities.containsKey(name)) {
          continue;
        }
        if (generator.entities.isEmpty()) {
          generator.processAll(false);
        }
        extendedEntities.putAll(name, generator.entities.get(name));
      }
    }
    for (String name : extendedEntities.keySet()) {
      final List<Entity> all = new ArrayList<>(extendedEntities.get(name));
      if (all == null || all.isEmpty()) {
        continue;
      }
      if (all.size() == 1 && !all.get(0).isModelClass()) { // generate extended Model class in root
        continue;
      }
      Collections.reverse(all);
      final List<File> rendered = render(all, false);
      if (rendered != null) {
        generated.addAll(rendered);
      }
    }

    // clean up obsolete files
    try (Stream<Path> walk = java.nio.file.Files.walk(outputPath.toPath())) {
      walk.map(Path::toFile)
          .filter(f -> f.getName().endsWith(".java") || f.getName().endsWith(".groovy"))
          .filter(f -> !generated.contains(f))
          .forEach(
              f -> {
                log.info("Deleting obsolete file: {}", f);
                f.delete();
              });
    }
  }

  /**
   * Get a {@link EntityGenerator} instance for the given source files.
   *
   * <p>Used by code generator task to add lookup source to core modules.
   *
   * @param files input files
   * @return a {@link EntityGenerator} instance
   */
  public static EntityGenerator forFiles(final Collection<File> files) {
    if (files == null || files.isEmpty()) {
      return null;
    }
    final EntityGenerator gen =
        new EntityGenerator(null, null) {

          @Override
          public void start() throws IOException {}

          @Override
          public void clean() {}

          @Override
          public void addLookupSource(EntityGenerator generator) throws IOException {}

          @Override
          protected void processAll(boolean verbose) throws IOException {
            for (File file : files) {
              process(file, verbose);
            }
          }
        };
    for (File file : files) {
      try {
        gen.findFrom(file);
      } catch (IOException e) {
      }
    }
    return gen;
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\EntityParser.java

package com.springforge.codegen.code.entity;

import com.springforge.codegen.code.entity.model.BaseType;
import com.springforge.codegen.code.entity.model.DomainModels;
import com.springforge.codegen.code.entity.model.Entity;
import com.springforge.codegen.code.entity.model.EnumType;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.JAXBException;
import jakarta.xml.bind.Unmarshaller;

public class EntityParser {

  private static final AtomicReference<JAXBContext> CONTEXT = new AtomicReference<>();

  private static JAXBContext getContext() throws JAXBException {
    if (CONTEXT.get() == null) {
      synchronized (CONTEXT) {
        CONTEXT.set(JAXBContext.newInstance(DomainModels.class));
      }
    }
    return CONTEXT.get();
  }

  public static List<BaseType<?>> parse(File file) throws JAXBException {
    JAXBContext context = getContext();
    Unmarshaller unmarshaller = context.createUnmarshaller();
    DomainModels domain = (DomainModels) unmarshaller.unmarshal(file);

    List<Entity> entities = domain.getEntities();
    List<EnumType> enums = domain.getEnums();

    List<BaseType<?>> types = new ArrayList<>();

    types.addAll(entities);
    types.addAll(enums);

    return types;
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\BaseType.java
package com.springforge.codegen.code.entity.model;

import com.springforge.codegen.code.JavaType;

public interface BaseType<T> {

  String getName();

  String getPackageName();

  JavaType toJavaClass();

  default JavaType toRepoClass() {
    return null;
  }

  void merge(T other);
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\DomainModels.java

package com.springforge.codegen.code.entity.model;

import java.util.ArrayList;
import java.util.List;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlRootElement;
import jakarta.xml.bind.annotation.XmlType;

@XmlType
@XmlRootElement(name = "domain-models")
public class DomainModels {

  @XmlElement(name = "module", required = true)
  private Namespace namespace;

  @XmlElement(name = "enum", type = EnumType.class)
  private List<EnumType> enums;

  @XmlElement(name = "entity", type = Entity.class)
  private List<Entity> entities;

  public Namespace getNamespace() {
    return namespace;
  }

  public void setNamespace(Namespace value) {
    this.namespace = value;
  }

  public List<EnumType> getEnums() {
    if (enums == null) {
      enums = new ArrayList<>();
    }
    return enums;
  }

  public void setEnums(List<EnumType> enums) {
    this.enums = enums;
  }

  public List<Entity> getEntities() {
    if (entities == null) {
      entities = new ArrayList<>();
    }
    return entities;
  }

  public void setEntities(List<Entity> entities) {
    this.entities = entities;
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\Entity.java
package com.springforge.codegen.code.entity.model;

import static com.springforge.codegen.code.entity.model.Utils.getterName;
import static com.springforge.codegen.code.entity.model.Utils.isBlank;
import static com.springforge.codegen.code.entity.model.Utils.isFalse;
import static com.springforge.codegen.code.entity.model.Utils.isTrue;
import static com.springforge.codegen.code.entity.model.Utils.notBlank;
import static com.springforge.codegen.code.entity.model.Utils.notEmpty;
import static com.springforge.codegen.code.entity.model.Utils.notFalse;
import static com.springforge.codegen.code.entity.model.Utils.notTrue;
import static com.springforge.codegen.code.entity.model.Utils.stream;

import com.springforge.common.Inflector;
import com.springforge.common.ObjectUtils;
import com.springforge.common.StringUtils;
import com.springforge.codegen.code.JavaAnnotation;
import com.springforge.codegen.code.JavaCode;
import com.springforge.codegen.code.JavaDoc;
import com.springforge.codegen.code.JavaField;
import com.springforge.codegen.code.JavaMethod;
import com.springforge.codegen.code.JavaType;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import jakarta.xml.bind.Unmarshaller;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlElements;
import jakarta.xml.bind.annotation.XmlMixed;
import jakarta.xml.bind.annotation.XmlTransient;
import jakarta.xml.bind.annotation.XmlType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@XmlType
public class Entity implements BaseType<Entity> {

  private static Set<String> INTERNAL_PACKAGES =
          Set.of("com.springforge.auth.db", "com.springforge.meta.db", "com.springforge.mail.db", "com.springforge.dms.db");

  @XmlMixed private List<String> comments;

  @XmlAttribute(name = "name", required = true)
  private String name;

  @XmlAttribute(name = "table")
  private String table;

  @XmlTransient private String packageName;

  @XmlTransient private String repoPackage;

  @XmlTransient private String tablePrefix;

  @XmlTransient boolean modelClass;

  @XmlTransient boolean dynamicUpdate;

  @XmlTransient Property idField;

  @XmlTransient Property attrsField;

  @XmlTransient Property nameField;

  @XmlAttribute(name = "sequential")
  private Boolean sequential;

  @XmlAttribute(name = "jsonAttrs")
  private Boolean jsonAttrs;

  @XmlAttribute(name = "logUpdates")
  private Boolean auditable;

  @XmlAttribute(name = "equalsIncludeAll")
  private Boolean equalsAll;

  @XmlAttribute(name = "cacheable")
  private Boolean cacheable;

  private Boolean mappedSuperClass;

  @XmlAttribute(name = "implements")
  private String superInterfaces;

  @XmlAttribute(name = "extends")
  private String superClass;

  @XmlAttribute(name = "strategy")
  private String strategy;

  @XmlAttribute(name = "repository")
  private String repositoryType;

  private transient boolean hasExtends;

  private static final Logger logger = LoggerFactory.getLogger(Entity.class);

  @XmlElements({
          @XmlElement(name = "string", type = Property.StringProperty.class),
          @XmlElement(name = "boolean", type = Property.BooleanProperty.class),
          @XmlElement(name = "integer", type = Property.IntegerProperty.class),
          @XmlElement(name = "decimal", type = Property.DecimalProperty.class),
          @XmlElement(name = "long", type = Property.LongProperty.class),
          @XmlElement(name = "date", type = Property.DateProperty.class),
          @XmlElement(name = "time", type = Property.TimeProperty.class),
          @XmlElement(name = "datetime", type = Property.DateTimeProperty.class),
          @XmlElement(name = "binary", type = Property.BinaryProperty.class),
          @XmlElement(name = "enum", type = Property.EnumProperty.class),
          @XmlElement(name = "one-to-one", type = Property.OneToOneProperty.class),
          @XmlElement(name = "many-to-one", type = Property.ManyToOneProperty.class),
          @XmlElement(name = "one-to-many", type = Property.OneToManyProperty.class),
          @XmlElement(name = "many-to-many", type = Property.ManyToManyProperty.class),
  })
  private List<Property> fields;

  @XmlElement(name = "index")
  private List<Index> indexes;

  @XmlElement(name = "unique-constraint")
  private List<UniqueConstraint> constraints;

  @XmlElement(name = "entity-listener")
  private List<EntityListener> listeners;

  @XmlElement(name = "finder-method")
  private List<Finder> finders;

  @XmlElement(name = "track")
  private Track track;

  @XmlElement(name = "extra-code")
  private String extraCode;

  @XmlElement(name = "extra-imports")
  private String extraImports;

  @XmlTransient Entity baseEntity;

  void afterUnmarshal(Unmarshaller unmarshaller, Object parent) {
    final Namespace ns = ((DomainModels) parent).getNamespace();
    packageName = ns.getPackageName();
    repoPackage = ns.getRepoPackageName();
    tablePrefix = ns.getTablePrefix();
    modelClass =
            notBlank(packageName)
                    && notBlank(name)
                    && packageName.equals("com.springforge.db")
                    && name.equals("Model");

    if (modelClass) {
      superClass = null;
      mappedSuperClass = true;
    }

    if (isBlank(tablePrefix)) {
      if (packageName.endsWith(".db")) {
        tablePrefix = packageName.replaceAll("\\.db$", "");
        tablePrefix = tablePrefix.substring(tablePrefix.lastIndexOf(".") + 1);
      } else {
        tablePrefix = ns.getName();
      }
    }

    if (isBlank(table)) {
      table = Inflector.getInstance().underscore(tablePrefix + name).toUpperCase();
    }

    if (isBlank(repoPackage)) {
      repoPackage = packageName + ".repo";
    }

    if (!modelClass) {
      if (isBlank(superClass)) {
        superClass =
                notFalse(auditable) ? "com.springforge.auth.db.AuditableModel" : "com.springforge.db.Model";
        idField = new Property.LongProperty();
        idField.setName("id");
      } else {
        hasExtends = true;
      }
    }

    boolean hasJsonAttrs = getFields().stream().anyMatch(p -> "attrs".equals(p.getName()));
    boolean addJsonAttrs =
            !modelClass
                    && !hasJsonAttrs
                    && (notFalse(jsonAttrs))
                    && (isTrue(jsonAttrs) || !INTERNAL_PACKAGES.contains(packageName));

    if (addJsonAttrs) {
      attrsField = new Property.StringProperty();
      attrsField.setName("attrs");
      attrsField.setTitle("Attributes");
      attrsField.setJson(true);
    }

    dynamicUpdate = getFields().stream().anyMatch(p -> p.isVirtual() && notTrue(p.getTransient()));
    nameField = getFields().stream().filter(p -> isTrue(p.getNameField())).findFirst().orElse(null);

    sequential = notFalse(sequential);
    equalsAll = isTrue(equalsAll);
  }

  public Property findField(String name) {
    return getFields().stream()
            .filter(p -> Objects.equals(p.getName(), name))
            .findFirst()
            .orElse(null);
  }

  @Override
  public void merge(Entity other) {
    for (Property prop : other.getFields()) {
      Property existing = findField(prop.getName());
      if (existing == null) {
        if (isTrue(prop.getInitParam())) {
          prop.setInitParam(false);
          logger.error("{}.{}: adding initParam is not allowed", getName(), prop.getName());
        }
        fields.add(prop);
      } else if (!merge(existing, prop)) {
        continue;
      }
      if (isTrue(prop.getNameField())) {
        nameField = Objects.requireNonNullElse(existing, prop);
      }
    }

    getIndexes().addAll(other.getIndexes());
    getConstraints().addAll(other.getConstraints());
    getFinders().addAll(other.getFinders());
    getListeners().addAll(other.getListeners());

    if (other.track != null) {
      if (track == null || isTrue(other.track.getReplace())) {
        track = other.track.copyFor(this);
      } else {
        track.merge(other.track);
      }
    }

    other.baseEntity = this;
    other.repositoryType = this.repositoryType;

    if (other.cacheable != null) {
      cacheable = other.cacheable;
    }

    extraImports =
            Stream.of(extraImports, other.extraImports)
                    .filter(Utils::notBlank)
                    .collect(Collectors.joining("\n"));

    extraCode =
            Stream.of(extraCode, other.extraCode)
                    .filter(Utils::notBlank)
                    .collect(Collectors.joining("\n"));
  }

  private boolean merge(Property existing, Property property) {
    if (!isCompatible(existing, property)) {
      return false;
    }

    try {
      for (final PropertyAttribute attribute : Property.getAttributes()) {
        merge(attribute, existing, property);
      }
    } catch (ReflectiveOperationException e) {
      throw new RuntimeException(e);
    }
    logger.trace("Merged {}.{}", getName(), existing.getName());
    return true;
  }

  private boolean isCompatible(Property existing, Property property) {
    if (existing.isPrimary()) {
      logger.error("{}.{}: cannot merge primary field", getName(), existing.getName());
      return false;
    }
    if (!Objects.equals(existing.getType(), property.getType())) {
      logger.error(
              "{}.{}: incompatible types: from '{}' to '{}'",
              getName(),
              existing.getName(),
              existing.getType(),
              property.getType());
      return false;
    }
    return true;
  }

  private void merge(PropertyAttribute attribute, Property existing, Property property)
          throws ReflectiveOperationException {
    final PropertyDescriptor descriptor = attribute.getDescriptor();
    final Method readMethod = descriptor.getReadMethod();
    Object otherValue = readMethod.invoke(property);

    if (attribute.isAbsent(otherValue)) {
      return;
    }

    otherValue = ObjectUtils.isEmpty(otherValue) ? null : otherValue;

    final Object value = readMethod.invoke(existing);

    if (Objects.equals(value, otherValue)) {
      return;
    }

    try {
      attribute.checkOverride(value, otherValue);
    } catch (IllegalArgumentException e) {
      logger.error(
              "{}.{}: attribute '{}': {}: from '{}' to '{}'",
              getName(),
              existing.getName(),
              attribute.getName(),
              e.getMessage(),
              value,
              otherValue);
      return;
    }

    descriptor.getWriteMethod().invoke(existing, otherValue);
    logger.debug(
            "{}.{}: attribute '{}' is overridden: from '{}' to '{}'",
            getName(),
            existing.getName(),
            attribute.getName(),
            value,
            otherValue);
  }

  public boolean addField(Property field) {
    for (Property current : getFields()) {
      if (Objects.equals(current.getName(), field.getName())) {
        return false;
      }
    }
    if (fields == null) {
      fields = new ArrayList<>();
    }
    fields.add(field);
    return true;
  }

  public boolean isModelClass() {
    return modelClass;
  }

  public List<String> getComments() {
    if (comments == null) {
      comments = new ArrayList<>();
    }
    return comments;
  }

  public void setComments(List<String> comments) {
    this.comments = comments;
  }

  public String getName() {
    return name;
  }

  public void setName(String value) {
    this.name = value;
  }

  public String getPackageName() {
    return packageName;
  }

  public String getTable() {
    return table;
  }

  public void setTable(String value) {
    this.table = value;
  }

  public Property getNameField() {
    return nameField;
  }

  public Boolean getSequential() {
    return sequential;
  }

  public void setSequential(Boolean sequential) {
    this.sequential = sequential;
  }

  public Boolean getJsonAttrs() {
    return jsonAttrs;
  }

  public void setJsonAttrs(Boolean jsonAttrs) {
    this.jsonAttrs = jsonAttrs;
  }

  public Boolean getAuditable() {
    return auditable;
  }

  public void setAuditable(Boolean auditable) {
    this.auditable = auditable;
  }

  public Boolean getEqualsAll() {
    return equalsAll;
  }

  public void setEqualsAll(Boolean equalsAll) {
    this.equalsAll = equalsAll;
  }

  public Boolean getCacheable() {
    return cacheable;
  }

  public void setCacheable(Boolean cacheable) {
    this.cacheable = cacheable;
  }

  public Boolean getMappedSuperClass() {
    return mappedSuperClass;
  }

  public void setMappedSuperClass(Boolean mappedSuperClass) {
    this.mappedSuperClass = mappedSuperClass;
  }

  @XmlAttribute(name = "persistable")
  public Boolean getPersistable() {
    return mappedSuperClass == null ? null : !mappedSuperClass;
  }

  public void setPersistable(Boolean persistable) {
    mappedSuperClass = persistable == null ? null : !persistable;
  }

  public void setConstraints(List<UniqueConstraint> constraints) {
    this.constraints = constraints;
  }

  public String getSuperClass() {
    return superClass;
  }

  public void setSuperClass(String superClass) {
    this.superClass = superClass;
  }

  public String getSuperInterfaces() {
    return superInterfaces;
  }

  // ... suite du code précédent ...

  public void setSuperInterfaces(String superInterfaces) {
    this.superInterfaces = superInterfaces;
  }

  public String getStrategy() {
    return strategy;
  }

  public void setStrategy(String value) {
    this.strategy = value;
  }

  public String getRepoPackage() {
    return repoPackage;
  }

  public String getRepositoryType() {
    return repositoryType;
  }

  public void setRepositoryType(String repositoryType) {
    this.repositoryType = repositoryType;
  }

  public List<Property> getFields() {
    if (fields == null) {
      fields = new ArrayList<>();
    }
    return fields;
  }

  public List<Index> getIndexes() {
    if (indexes == null) {
      indexes = new ArrayList<>();
    }
    return indexes;
  }

  public List<UniqueConstraint> getConstraints() {
    if (constraints == null) {
      constraints = new ArrayList<>();
    }
    return constraints;
  }

  public List<EntityListener> getListeners() {
    if (listeners == null) {
      listeners = new ArrayList<>();
    }
    return listeners;
  }

  public List<Finder> getFinders() {
    if (finders == null) {
      finders = new ArrayList<>();
    }
    return finders;
  }

  public Track getTrack() {
    return track;
  }

  public void setTrack(Track track) {
    this.track = track;
  }

  public String getExtraCode() {
    return extraCode;
  }

  public String getExtraImports() {
    return extraImports;
  }

  private JavaAnnotation $entity() {
    return isTrue(mappedSuperClass) ? null : new JavaAnnotation("jakarta.persistence.Entity");
  }

  private JavaAnnotation $table() {
    if (isBlank(table) || isTrue(mappedSuperClass)) return null;

    JavaAnnotation annotation =
            new JavaAnnotation("jakarta.persistence.Table").param("name", "{0:s}", table);

    List<Index> indexes = new ArrayList<>(getIndexes());

    getFields().stream().map(Property::createIndex).filter(Objects::nonNull).forEach(indexes::add);

    annotation.param("uniqueConstraints", getConstraints(), x -> x.toJavaAnnotation(this));
    annotation.param("indexes", indexes, x -> x.toJavaAnnotation(this));

    return annotation;
  }

  private JavaAnnotation $cacheable() {
    if (modelClass || cacheable == null) return null;
    if (isTrue(cacheable)) {
      return new JavaAnnotation("jakarta.persistence.Cacheable");
    }
    if (isFalse(cacheable)) {
      return new JavaAnnotation("jakarta.persistence.Cacheable").param("value", "false");
    }
    return null;
  }

  private JavaAnnotation $mappedSuperClass() {
    return isTrue(mappedSuperClass)
            ? new JavaAnnotation("jakarta.persistence.MappedSuperclass")
            : null;
  }

  private JavaAnnotation $strategy() {
    // Inheritance strategy can be specified on root entity only
    if (isBlank(strategy) || hasExtends) return null;
    String type = "SINGLE_TABLE";
    if (strategy.equals("JOINED")) type = "JOINED";
    if (strategy.equals("CLASS")) type = "TABLE_PER_CLASS";

    return new JavaAnnotation("jakarta.persistence.Inheritance")
            .param("strategy", "{0:m}", "jakarta.persistence.InheritanceType." + type);
  }

  private JavaAnnotation $listeners() {
    if (listeners == null || listeners.isEmpty()) return null;
    return new JavaAnnotation("jakarta.persistence.EntityListeners")
            .param("value", listeners, t -> new JavaCode("{0:t}.class", t.getClazz()));
  }

  private JavaAnnotation $track() {
    return track == null ? null : track.toJavaAnnotation();
  }

  public List<JavaAnnotation> getAnnotations() {
    List<JavaAnnotation> all = new ArrayList<>();

    if (notTrue(mappedSuperClass)) {
      all.add($entity());
      all.add($cacheable());
    }

    if (notTrue(mappedSuperClass) && isTrue(dynamicUpdate)) {
      all.add(new JavaAnnotation("org.hibernate.annotations.DynamicInsert"));
      all.add(new JavaAnnotation("org.hibernate.annotations.DynamicUpdate"));
    }

    all.add($table());
    all.add($strategy());
    all.add($track());
    all.add($mappedSuperClass());
    all.add($listeners());

    return all.stream().filter(Objects::nonNull).collect(Collectors.toList());
  }

  private List<Property> getEqualsIncludes() {
    return getFields().stream()
            .filter(
                    p -> {
                      if (p.isPrimary() || p.isVersion() || isFalse(p.getEqualsInclude())) return false;
                      if (isTrue(p.getEqualsInclude()) || isTrue(p.getUnique())) return true;
                      return isTrue(equalsAll) && p.isSimple() && !p.isVirtual();
                    })
            .collect(Collectors.toList());
  }

  private List<JavaMethod> toConstructors() {
    JavaMethod m1 = new JavaMethod(name, null, Modifier.PUBLIC);
    JavaMethod m2 = new JavaMethod(name, null, Modifier.PUBLIC);

    if (hasExtends) {
      return List.of(m1);
    }

    List<Property> fields =
            getFields().stream().filter(p -> isTrue(p.getInitParam())).collect(Collectors.toList());
    if (fields.isEmpty()) {
      fields =
              getFields().stream()
                      .filter(p -> p.getName().matches("name|code"))
                      .collect(Collectors.toList());
    }

    if (fields.isEmpty()) {
      return List.of(m1);
    }

    fields.forEach(
            p -> {
              m2.param(p.getName(), p.getJavaType());
              m2.code("this.{0:l} = {0:l};", p.getName());
            });

    return List.of(m1, m2);
  }

  private JavaMethod createEqualsMethod() {
    final JavaMethod method =
            new JavaMethod("equals", "boolean", Modifier.PUBLIC)
                    .annotation(new JavaAnnotation("Override"))
                    .param("obj", "Object");

    if (hasExtends) {
      method.code("return {0:t}.equals(this, obj);", "com.springforge.db.EntityHelper");
      return method;
    }

    method.code("if (obj == null) return false;");
    method.code("if (this == obj) return true;");
    method.code("if (!(obj instanceof {0:l})) return false;", getName());
    method.code("");
    method.code("final {0:l} other = ({0:l}) obj;", getName());
    method.code("if (this.getId() != null || other.getId() != null) {");
    method.code("  return {0:t}.equals(this.getId(), other.getId());", "java.util.Objects");
    method.code("}");
    method.code("");

    var data = getEqualsIncludes();

    if (data.isEmpty()) {
      method.code("return false;");
      return method;
    }

    var conditions =
            data.stream()
                    .map(p -> p.getName())
                    .map(n -> getterName(n))
                    .map(n -> String.format("Objects.equals(%s(), other.%s())", n, n))
                    .collect(Collectors.joining("\n  && "));

    var nullconditions =
            data.stream()
                    .map(p -> p.getName())
                    .map(n -> getterName(n))
                    .map(n -> String.format("%s() != null", n))
                    .collect(Collectors.joining("\n    || "));

    method.code("return " + conditions);
    method.code("  && (" + nullconditions + ");");

    return method;
  }

  private JavaMethod createHashCodeMethod() {
    final JavaMethod method =
            new JavaMethod("hashCode", "int", Modifier.PUBLIC)
                    .annotation(new JavaAnnotation("Override"));

    return method.code("return 31;");
  }

  private boolean canToString(Property property) {
    return !property.isPrimary()
            && !property.isVersion()
            && !property.isVirtual()
            && isTrue(property.isSimple())
            && notTrue(property.getJson())
            && notTrue(property.getPassword());
  }

  private JavaMethod createToStringMethod() {
    final JavaMethod method =
            new JavaMethod("toString", "String", Modifier.PUBLIC)
                    .annotation(new JavaAnnotation("Override"));

    if (hasExtends) {
      method.code("return {0:t}.toString(this);", "com.springforge.db.EntityHelper");
      return method;
    }

    method.code("return {0:t}.toStringHelper(this)", "com.google.common.base.MoreObjects");
    method.code(" .add({0:s}, getId())", "id");

    getFields().stream()
            .filter(this::canToString)
            .limit(10)
            .forEach(p -> method.code("  .add({0:s}, {1:l}())", p.getName(), getterName(p.getName())));

    method.code("  .omitNullValues()");
    method.code("  .toString();");

    return method;
  }

  @Override
  public JavaType toJavaClass() {
    int modifiers = isModelClass() ? Modifier.PUBLIC | Modifier.ABSTRACT : Modifier.PUBLIC;
    JavaType pojo = JavaType.newClass(name, modifiers);

    if (notBlank(superClass)) pojo.superType(superClass);
    if (notEmpty(superInterfaces)) stream(superInterfaces).forEach(pojo::superInterface);

    List<JavaAnnotation> annotations = getAnnotations();
    List<JavaField> fields = new ArrayList<>();
    List<JavaMethod> methods = new ArrayList<>();

    if (idField != null) {
      fields.add(idField.toJavaField(this));
      methods.addAll(idField.toJavaMethods());
    }

    for (Property property : getFields()) {
      fields.add(property.toJavaField(this));
      methods.addAll(property.toJavaMethods());
    }

    if (attrsField != null) {
      fields.add(attrsField.toJavaField(this));
      methods.addAll(attrsField.toJavaMethods());
    }

    annotations.forEach(pojo::annotation);

    if (modelClass) {
      JavaField id = new JavaField("id", "Long");
      JavaField cid = new JavaField("cid", "Long", Modifier.PRIVATE | Modifier.TRANSIENT);
      JavaField version = new JavaField("version", "Integer", Modifier.PRIVATE);
      JavaField selected =
              new JavaField("selected", "boolean", Modifier.PRIVATE | Modifier.TRANSIENT);
      JavaField archived = new JavaField("archived", "Boolean", Modifier.PRIVATE);

      cid.annotation(new JavaAnnotation("jakarta.persistence.Transient"));
      version.annotation(new JavaAnnotation("jakarta.persistence.Version"));
      selected.annotation(new JavaAnnotation("jakarta.persistence.Transient"));
      archived.annotation(
              new JavaAnnotation("com.springforge.db.annotations.Widget").param("massUpdate", "true"));

      pojo.field(cid);
      pojo.field(version);
      pojo.field(selected);
      pojo.field(archived);

      pojo.method(id.getGetterMethod().modifiers(Modifier.PUBLIC | Modifier.ABSTRACT));
      pojo.method(id.getSetterMethod().modifiers(Modifier.PUBLIC | Modifier.ABSTRACT));

      pojo.method(cid.getGetterMethod());
      pojo.method(cid.getSetterMethod());

      pojo.method(version.getGetterMethod());
      pojo.method(version.getSetterMethod());

      pojo.method(selected.getGetterMethod());
      pojo.method(selected.getSetterMethod());

      pojo.method(archived.getGetterMethod());
      pojo.method(archived.getSetterMethod());
    }

    fields.forEach(pojo::field);
    methods.forEach(pojo::method);

    if (!modelClass) {
      toConstructors().forEach(pojo::constructor);
      pojo.method(createEqualsMethod());
      pojo.method(createHashCodeMethod());
      pojo.method(createToStringMethod());
    }

    getComments().stream()
            .filter(s -> notBlank(s))
            .findFirst()
            .ifPresent(
                    comment -> {
                      String text = StringUtils.stripIndent(comment).trim();
                      Iterator<String> iter = Stream.of(text.split("\n", -1)).iterator();
                      JavaDoc doc = new JavaDoc(iter.next());
                      // skip initial blank lines
                      while (iter.hasNext()) {
                        String next = iter.next();
                        if (notBlank(next)) {
                          doc.line(next);
                          break;
                        }
                      }
                      iter.forEachRemaining(doc::line);
                      pojo.doc(doc);
                    });

    String extraImports = getExtraImports();
    if (StringUtils.notBlank(extraImports)) {
      pojo.rawImports(extraImports.split("\n"));
    }

    return pojo;
  }

  @Override
  public JavaType toRepoClass() {
    if ("none".equals(repositoryType) || isTrue(mappedSuperClass) || isModelClass()) {
      return null;
    }

    boolean isAbstract = "abstract".equals(repositoryType);
    String modelClassName = getName();
    String modelClass = getPackageName() + "." + getName();
    String baseClass = "com.springforge.db.JpaRepository<" + modelClass + ">";
    String className =
            isAbstract
                    ? MessageFormat.format("Abstract{0}Repository", modelClassName)
                    : MessageFormat.format("{0}Repository", modelClassName);

    int modifiers = isAbstract ? Modifier.PUBLIC | Modifier.ABSTRACT : Modifier.PUBLIC;

    JavaType pojo =
            JavaType.newClass(className, modifiers)
                    .superType(baseClass)
                    .constructor(
                            new JavaMethod(className, null, Modifier.PUBLIC)
                                    .code("super({0:t}.class);", modelClass));

    List<Finder> finders = new ArrayList<>(getFinders());

    boolean hasCodeFinder =
            finders.stream().anyMatch(finder -> "findByCode".equals(finder.getName()));
    boolean hasNameFinder =
            finders.stream().anyMatch(finder -> "findByName".equals(finder.getName()));

    Property code = findField("code");
    Property name = findField("name");

    if (!hasCodeFinder && code != null) pojo.method(new Finder("code").toJavaMethod(this));
    if (!hasNameFinder && name != null) pojo.method(new Finder("name").toJavaMethod(this));

    getFinders().stream()
            .map(finder -> finder.toJavaMethod(this))
            .filter(Objects::nonNull)
            .forEach(pojo::method);

    String extraImports = getExtraImports();
    if (StringUtils.notBlank(extraImports)) {
      pojo.rawImports(extraImports.split("\n"));
    }

    String extraCode = getExtraCode();
    if (StringUtils.notBlank(extraCode)) {
      pojo.rawCode(StringUtils.stripIndent(extraCode).trim());
    }

    return pojo;
  }
}
// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\EntityListener.java

package com.springforge.codegen.code.entity.model;

import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlType;

@XmlType
public class EntityListener {

  @XmlAttribute(name = "class", required = true)
  private String clazz;

  public String getClazz() {
    return clazz;
  }

  public void setClazz(String value) {
    this.clazz = value;
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\EnumItem.java

package com.springforge.codegen.code.entity.model;

import static com.springforge.codegen.code.entity.model.Utils.isTrue;
import static com.springforge.codegen.code.entity.model.Utils.notBlank;

import com.springforge.common.StringUtils;
import com.springforge.codegen.code.JavaAnnotation;
import com.springforge.codegen.code.JavaCode;
import com.springforge.codegen.code.JavaDoc;
import com.springforge.codegen.code.JavaEnumConstant;
import java.util.HashMap;
import java.util.Map;
import jakarta.xml.bind.Unmarshaller;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlTransient;
import jakarta.xml.bind.annotation.XmlType;

@XmlType
public class EnumItem {

  @XmlAttribute(name = "name", required = true)
  private String name;

  @XmlAttribute(name = "title")
  private String title;

  @XmlAttribute(name = "value")
  private String value;

  @XmlAttribute(name = "help")
  private String help;

  @XmlAttribute(name = "data-description")
  private String description;

  @XmlAttribute(name = "icon")
  private String icon;

  @XmlAttribute(name = "hidden")
  private Boolean hidden;

  @XmlAttribute(name = "order")
  private Integer order;

  @XmlTransient private boolean numeric;

  void afterUnmarshal(Unmarshaller unmarshaller, Object parent) {
    final EnumType et = ((EnumType) parent);
    this.numeric = isTrue(et.getNumeric());
  }

  public String getName() {
    return name;
  }

  public void setName(String value) {
    this.name = value;
  }

  public String getTitle() {
    return title;
  }

  public void setTitle(String value) {
    this.title = value;
  }

  public String getValue() {
    return value;
  }

  public void setValue(String value) {
    this.value = value;
  }

  public String getHelp() {
    return help;
  }

  public void setHelp(String value) {
    this.help = value;
  }

  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public String getIcon() {
    return icon;
  }

  public void setIcon(String icon) {
    this.icon = icon;
  }

  public Boolean getHidden() {
    return hidden;
  }

  public void setHidden(Boolean hidden) {
    this.hidden = hidden;
  }

  public Integer getOrder() {
    return order;
  }

  public void setOrder(Integer order) {
    this.order = order;
  }

  public JavaEnumConstant toJavaEnumConstant() {
    JavaEnumConstant constant = new JavaEnumConstant(name);
    if (notBlank(value)) {
      JavaCode arg = numeric ? new JavaCode("{0:l}", value) : new JavaCode("{0:s}", value);
      constant.arg(arg);
    }

    JavaAnnotation enumAnnotation = new JavaAnnotation("com.springforge.db.annotations.EnumWidget");
    Map<String, JavaCode> params = new HashMap<>();

    if (notBlank(title)) {
      params.put("title", new JavaCode("{0:s}", title));
    }
    if (notBlank(description)) {
      params.put("description", new JavaCode("{0:s}", description));
    }
    if (notBlank(icon)) {
      params.put("icon", new JavaCode("{0:s}", icon));
    }
    if (order != null) {
      params.put("order", new JavaCode("{0:l}", order));
    }
    if (hidden != null) {
      params.put("hidden", new JavaCode("{0:l}", hidden));
    }

    if (!params.isEmpty()) {
      params.forEach(enumAnnotation::param);
      constant.annotation(enumAnnotation);
    }

    if (notBlank(help)) {
      constant.doc(new JavaDoc(StringUtils.stripIndent(help)));
    }

    return constant;
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\EnumType.java

package com.springforge.codegen.code.entity.model;

import static com.springforge.codegen.code.entity.model.Utils.isTrue;
import static com.springforge.codegen.code.entity.model.Utils.notBlank;

import com.springforge.codegen.code.JavaAnnotation;
import com.springforge.codegen.code.JavaField;
import com.springforge.codegen.code.JavaMethod;
import com.springforge.codegen.code.JavaType;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Consumer;
import jakarta.xml.bind.Unmarshaller;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlTransient;
import jakarta.xml.bind.annotation.XmlType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@XmlType
public class EnumType implements BaseType<EnumType> {

  @XmlTransient private String packageName;

  @XmlAttribute(name = "name", required = true)
  private String name;

  @XmlAttribute(name = "numeric")
  private Boolean numeric;

  @XmlElement(name = "item")
  private List<EnumItem> items;

  private static final Logger logger = LoggerFactory.getLogger(EnumType.class);

  void afterUnmarshal(Unmarshaller unmarshaller, Object parent) {
    final Namespace ns = ((DomainModels) parent).getNamespace();
    this.packageName = ns.getPackageName();
  }

  public String getPackageName() {
    return packageName;
  }

  public String getName() {
    return name;
  }

  public void setName(String value) {
    this.name = value;
  }

  public Boolean getNumeric() {
    return numeric;
  }

  public void setNumeric(Boolean value) {
    this.numeric = value;
  }

  public List<EnumItem> getItems() {
    if (items == null) {
      items = new ArrayList<>();
    }
    return this.items;
  }

  public EnumItem findItem(String name) {
    return getItems().stream()
        .filter(p -> Objects.equals(p.getName(), name))
        .findFirst()
        .orElse(null);
  }

  @Override
  public void merge(EnumType other) {
    for (EnumItem item : other.items) {
      EnumItem existing = findItem(item.getName());
      if (existing == null) {
        items.add(item);
      } else {
        merge(existing, item);
      }
    }
  }

  private void merge(EnumItem existing, EnumItem item) {
    merge(existing.getName(), "title", existing.getTitle(), item.getTitle(), existing::setTitle);
    dontMerge(existing.getName(), "value", existing.getValue(), item.getValue());
    merge(existing.getName(), "help", existing.getHelp(), item.getHelp(), existing::setHelp);
    merge(existing.getName(), "icon", existing.getIcon(), item.getIcon(), existing::setIcon);
    merge(
        existing.getName(),
        "description",
        existing.getDescription(),
        item.getDescription(),
        existing::setDescription);
    merge(
        existing.getName(), "hidden", existing.getHidden(), item.getHidden(), existing::setHidden);
    merge(existing.getName(), "order", existing.getOrder(), item.getOrder(), existing::setOrder);
    logger.trace("Merged {}.{}", getName(), existing.getName());
  }

  private <T> void merge(String itemName, String name, T value, T otherValue, Consumer<T> setter) {
    Optional.ofNullable(otherValue)
        .ifPresent(
            v -> {
              setter.accept(v);
              logger.debug(
                  "{}.{}: attribute '{}' is overridden: from '{}' to '{}'",
                  getName(),
                  itemName,
                  name,
                  value,
                  otherValue);
            });
  }

  private <T> void dontMerge(String itemName, String name, T value, T otherValue) {
    Optional.ofNullable(otherValue)
        .ifPresent(
            v ->
                logger.error(
                    "{}.{}: attribute '{}' is not overriddable: from '{}' to '{}'",
                    getName(),
                    itemName,
                    name,
                    value,
                    otherValue));
  }

  @Override
  public JavaType toJavaClass() {
    String type = isTrue(numeric) ? "Integer" : "String";
    JavaType pojo = JavaType.newEnum(getName(), Modifier.PUBLIC);

    pojo.superInterface("com.springforge.db.ValueEnum<" + type + ">");

    if (items == null) {
      return pojo;
    }

    items.forEach(item -> pojo.enumConstant(item.toJavaEnumConstant()));

    boolean isValueEnum = items.stream().anyMatch(item -> notBlank(item.getValue()));

    pojo.method(
        new JavaMethod("getValue", type, Modifier.PUBLIC)
            .annotation(new JavaAnnotation("Override"))
            .code(isValueEnum ? "return value;" : "return name();"));

    if (isValueEnum) {
      pojo.field(new JavaField("value", type, Modifier.PRIVATE | Modifier.FINAL));
      pojo.constructor(
          new JavaMethod(name, null, Modifier.PRIVATE)
              .param("value", type)
              .code("this.value = {0:t}.requireNonNull(value);", "java.util.Objects"));
    }

    return pojo;
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\Finder.java

package com.springforge.codegen.code.entity.model;

import static com.springforge.codegen.code.entity.model.Utils.*;
import static com.springforge.codegen.code.entity.model.Utils.isFalse;
import static com.springforge.codegen.code.entity.model.Utils.isTrue;
import static com.springforge.codegen.code.entity.model.Utils.list;
import static com.springforge.codegen.code.entity.model.Utils.notBlank;

import com.springforge.codegen.code.JavaCode;
import com.springforge.codegen.code.JavaCodeUtils;
import com.springforge.codegen.code.JavaMethod;
import com.springforge.codegen.code.JavaParam;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlType;

@XmlType
public class Finder {

  private static final Map<String, String> TYPES = new HashMap<>();

  static {
    TYPES.put("int", "int");
    TYPES.put("long", "long");
    TYPES.put("double", "double");
    TYPES.put("boolean", "boolean");
    TYPES.put("Integer", "Integer");
    TYPES.put("Long", "Long");
    TYPES.put("Double", "Double");
    TYPES.put("Boolean", "Boolean");
    TYPES.put("String", "String");
    TYPES.put("LocalDate", "java.time.LocalDate");
    TYPES.put("LocalTime", "java.time.LocalTime");
    TYPES.put("LocalDateTime", "java.time.LocalDateTime");
    TYPES.put("ZonedDateTime", "java.time.ZonedDateTime");
    TYPES.put("BigDecimal", "java.math.BigDecimal");
  }

  public Finder() {}

  Finder(String field) {
    this.name = methodName("findBy", field);
    this.using = field;
  }

  @XmlAttribute(name = "name", required = true)
  private String name;

  @XmlAttribute(name = "using", required = true)
  private String using;

  @XmlAttribute(name = "filter")
  private String filter;

  @XmlAttribute(name = "orderBy")
  private String orderBy;

  @XmlAttribute(name = "all")
  private Boolean all;

  @XmlAttribute(name = "cacheable")
  private Boolean cacheable;

  @XmlAttribute(name = "flush")
  private Boolean flush;

  public String getName() {
    return name;
  }

  public void setName(String value) {
    this.name = value;
  }

  public String getUsing() {
    return using;
  }

  public void setUsing(String value) {
    this.using = value;
  }

  public String getFilter() {
    return filter;
  }

  public void setFilter(String value) {
    this.filter = value;
  }

  public String getOrderBy() {
    return orderBy;
  }

  public void setOrderBy(String value) {
    this.orderBy = value;
  }

  public Boolean getAll() {
    if (all == null) {
      return false;
    } else {
      return all;
    }
  }

  public void setAll(Boolean value) {
    this.all = value;
  }

  public Boolean getCacheable() {
    if (cacheable == null) {
      return false;
    } else {
      return cacheable;
    }
  }

  public void setCacheable(Boolean value) {
    this.cacheable = value;
  }

  public Boolean getFlush() {
    if (flush == null) {
      return true;
    } else {
      return flush;
    }
  }

  public void setFlush(Boolean value) {
    this.flush = value;
  }

  public JavaMethod toJavaMethod(Entity entity) {
    int modifiers = Modifier.PUBLIC;
    String finderName = name;
    String finderType = entity.getName(); // entity name

    if (isTrue(all)) {
      finderType = "com.springforge.db.Query<" + finderType + ">";
    }

    JavaMethod method = new JavaMethod(finderName, finderType, modifiers);

    List<String> query = new ArrayList<>();
    List<String> args = new ArrayList<>();
    List<JavaParam> params = new ArrayList<>();

    for (String field : list(using)) {
      String[] parts = field.split(":");
      String propName = JavaCodeUtils.firstLower(field);
      String propType;
      Property prop;
      if (parts.length > 1) {
        if (filter.isEmpty()) return null; // filter must be provided
        propType = parts[0];
        propName = parts[1];
        if (TYPES.containsKey(propType)) {
          propType = TYPES.get(propType);
        } else {
          propType = parts[0];
        }
      } else {
        prop = entity.findField(propName);
        if (prop == null && entity.baseEntity != null) prop = entity.baseEntity.findField(propName);
        if (prop == null) return null;
        propType = prop.getJavaType();

        if (notBlank(prop.getTarget())) {
          propType =
              prop.getTarget().indexOf('.') == -1
                  ? entity.getPackageName() + "." + propType
                  : prop.getTarget();
        }
        query.add(String.format("self.%s = :%s", propName, propName));
      }
      propName = JavaCodeUtils.firstLower(propName);

      args.add(propName);
      params.add(new JavaParam(propName, propType));
    }

    params.forEach(method::param);

    String queryString = isBlank(filter) ? String.join(" AND ", query) : filter;

    List<JavaCode> code = new ArrayList<>();

    code.add(new JavaCode("return {0:t}.of({1:t}.class)", "com.springforge.db.Query", entity.getName()));
    code.add(new JavaCode("  .filter({0:s})", queryString));

    args.forEach(n -> code.add(new JavaCode("  .bind({0:s}, {0:l})", n)));
    list(orderBy).forEach(n -> code.add(new JavaCode("  .order({0:s})", n)));

    if (isTrue(cacheable)) {
      code.add(new JavaCode("  .cacheable()"));
    }
    if (isFalse(flush)) {
      code.add(new JavaCode("  .autoFlush(false)"));
    }

    if (finderType.equals(entity.getName())) {
      code.add(new JavaCode("  .fetchOne()"));
    }

    code.get(code.size() - 1).next(";");

    return method.code(code);
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\Index.java

package com.springforge.codegen.code.entity.model;

import static com.springforge.codegen.code.entity.model.Utils.*;

import com.springforge.codegen.code.JavaAnnotation;
import java.util.stream.Collectors;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlType;

@XmlType
public class Index {

  @XmlAttribute(name = "name")
  private String name;

  @XmlAttribute(name = "columns", required = true)
  private String columns;

  @XmlAttribute(name = "unique")
  private Boolean unique;

  public String getName() {
    return name;
  }

  public void setName(String value) {
    this.name = value;
  }

  public String getColumns() {
    return columns;
  }

  public void setColumns(String value) {
    this.columns = value;
  }

  public Boolean getUnique() {
    return unique;
  }

  public void setUnique(Boolean unique) {
    this.unique = unique;
  }

  protected String getColumn(Entity entity, String indexColumn) {
    String[] parts = indexColumn.split("\\s+");
    String field = parts[0];
    String orderBy = parts.length > 1 ? " " + parts[1] : "";

    Property property = entity.findField(field);
    if (property == null) {
      return indexColumn;
    }

    String column = property.getColumn();
    if (notBlank(column)) return column + orderBy;
    if (property.isReference()) return property.getColumnAuto() + orderBy;
    return indexColumn;
  }

  protected String getColumnList(Entity entity) {
    return list(getColumns()).stream()
        .map(column -> getColumn(entity, column))
        .collect(Collectors.joining(", "));
  }

  public JavaAnnotation toJavaAnnotation(Entity entity) {
    JavaAnnotation annotation =
        new JavaAnnotation("jakarta.persistence.Index")
            .param("columnList", "{0:s}", getColumnList(entity));
    if (notBlank(name)) {
      annotation.param("name", "{0:s}", name);
    }
    if (isTrue(unique)) {
      annotation.param("unique", "true");
    }
    return annotation;
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\Namespace.java

package com.springforge.codegen.code.entity.model;

import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlType;

@XmlType
public class Namespace {

  @XmlAttribute(name = "name", required = true)
  private String name;

  @XmlAttribute(name = "package", required = true)
  private String packageName;

  @XmlAttribute(name = "repo-package")
  private String repoPackageName;

  @XmlAttribute(name = "table-prefix")
  private String tablePrefix;

  public String getName() {
    return name;
  }

  public void setName(String value) {
    this.name = value;
  }

  public String getPackageName() {
    return packageName;
  }

  public void setPackageName(String value) {
    this.packageName = value;
  }

  public String getRepoPackageName() {
    return repoPackageName;
  }

  public void setRepoPackageName(String value) {
    this.repoPackageName = value;
  }

  public String getTablePrefix() {
    return tablePrefix;
  }

  public void setTablePrefix(String value) {
    this.tablePrefix = value;
  }

  @Override
  public String toString() {
    return "Namespace [name="
        + name
        + ", package="
        + packageName
        + ", repoPackage="
        + repoPackageName
        + ", tablePrefix="
        + tablePrefix
        + "]";
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\Naming.java

package com.springforge.codegen.code.entity.model;

import java.util.Set;

public class Naming {
  /** Check whether the given name is a reserved keyword. */
  public static boolean isReserved(String name) {
    return RESERVED_JAVA.contains(name) || RESERVED_EXTRA.contains(name);
  }

  /** Check whether the given name is SQL reserved keyword. */
  public static boolean isKeyword(String name) {
    return RESERVED_POSTGRESQL.contains(name)
        || RESERVED_MYSQL.contains(name)
        || RESERVED_ORACLE.contains(name);
  }

  /** Quote the given column name. */
  public static String quoteColumn(String name) {
    return "`" + name + "`";
  }

  // Internal Reserved
  private static final Set<String> RESERVED_EXTRA =
      Set.of("version", "archived", "selected", "constructor");

  // Java Keywords
  private static final Set<String> RESERVED_JAVA =
      Set.of(
          "abstract",
          "assert",
          "boolean",
          "break",
          "byte",
          "case",
          "catch",
          "char",
          "class",
          "const",
          "continue",
          "default",
          "do",
          "double",
          "else",
          "enum",
          "extends",
          "final",
          "finally",
          "float",
          "for",
          "goto",
          "if",
          "implements",
          "import",
          "instanceof",
          "int",
          "interface",
          "long",
          "native",
          "new",
          "package",
          "private",
          "protected",
          "public",
          "return",
          "short",
          "static",
          "strictfp",
          "super",
          "switch",
          "synchronized",
          "this",
          "throw",
          "throws",
          "transient",
          "try",
          "void",
          "volatile",
          "while");

  // PostgreSQL 9.6 to PostgreSQL 14
  private static final Set<String> RESERVED_POSTGRESQL =
      Set.of(
          "all",
          "analyse",
          "analyze",
          "and",
          "any",
          "array",
          "as",
          "asc",
          "asymmetric",
          "authorization",
          "binary",
          "both",
          "case",
          "cast",
          "check",
          "collate",
          "collation",
          "column",
          "concurrently",
          "constraint",
          "create",
          "cross",
          "current_catalog",
          "current_date",
          "current_role",
          "current_schema",
          "current_time",
          "current_timestamp",
          "current_user",
          "default",
          "deferrable",
          "desc",
          "distinct",
          "do",
          "else",
          "end",
          "except",
          "false",
          "fetch",
          "for",
          "foreign",
          "freeze",
          "from",
          "full",
          "grant",
          "group",
          "having",
          "ilike",
          "in",
          "initially",
          "inner",
          "intersect",
          "into",
          "is",
          "isnull",
          "join",
          "lateral",
          "leading",
          "left",
          "like",
          "limit",
          "localtime",
          "localtimestamp",
          "natural",
          "not",
          "notnull",
          "null",
          "offset",
          "on",
          "only",
          "or",
          "order",
          "outer",
          "overlaps",
          "placing",
          "primary",
          "references",
          "returning",
          "right",
          "select",
          "session_user",
          "similar",
          "some",
          "symmetric",
          "table",
          "tablesample",
          "then",
          "to",
          "trailing",
          "true",
          "union",
          "unique",
          "user",
          "using",
          "variadic",
          "verbose",
          "when",
          "where",
          "window",
          "with");

  //  MySQL 5.7 / 8.0
  private static final Set<String> RESERVED_MYSQL =
      Set.of(
          "accessible",
          "add",
          "all",
          "alter",
          "analyse",
          "analyze",
          "and",
          "any",
          "array",
          "as",
          "asc",
          "asensitive",
          "asymmetric",
          "authorization",
          "before",
          "between",
          "bigint",
          "binary",
          "blob",
          "both",
          "by",
          "call",
          "cascade",
          "case",
          "cast",
          "change",
          "char",
          "character",
          "check",
          "collate",
          "collation",
          "column",
          "condition",
          "constraint",
          "continue",
          "convert",
          "create",
          "cross",
          "cube",
          "cume_dist",
          "current_catalog",
          "current_date",
          "current_role",
          "current_schema",
          "current_time",
          "current_timestamp",
          "current_user",
          "cursor",
          "database",
          "databases",
          "day_hour",
          "day_microsecond",
          "day_minute",
          "day_second",
          "dec",
          "decimal",
          "declare",
          "default",
          "deferrable",
          "delayed",
          "delete",
          "dense_rank",
          "desc",
          "describe",
          "deterministic",
          "distinct",
          "distinctrow",
          "div",
          "do",
          "double",
          "drop",
          "dual",
          "each",
          "else",
          "elseif",
          "empty",
          "enclosed",
          "end",
          "escaped",
          "except",
          "exists",
          "exit",
          "explain",
          "false",
          "fetch",
          "first_value",
          "float",
          "float4",
          "float8",
          "for",
          "force",
          "foreign",
          "from",
          "full",
          "fulltext",
          "function",
          "generated",
          "get",
          "grant",
          "group",
          "grouping",
          "groups",
          "having",
          "high_priority",
          "hour_microsecond",
          "hour_minute",
          "hour_second",
          "if",
          "ignore",
          "in",
          "index",
          "infile",
          "initially",
          "inner",
          "inout",
          "insensitive",
          "insert",
          "int",
          "int1",
          "int2",
          "int3",
          "int4",
          "int8",
          "integer",
          "intersect",
          "interval",
          "into",
          "io_after_gtids",
          "io_before_gtids",
          "is",
          "iterate",
          "join",
          "json_table",
          "key",
          "kill",
          "lag",
          "last_value",
          "lateral",
          "lead",
          "leading",
          "leave",
          "left",
          "like",
          "limit",
          "linear",
          "lines",
          "load",
          "localtime",
          "localtimestamp",
          "lock",
          "long",
          "longblob",
          "longtext",
          "loop",
          "low_priority",
          "master_bind",
          "master_ssl_verify_server_cert",
          "match",
          "maxvalue",
          "mediumblob",
          "mediumint",
          "mediumtext",
          "middleint",
          "minute_microsecond",
          "minute_second",
          "mod",
          "modifies",
          "natural",
          "no_write_to_binlog",
          "not",
          "nth_value",
          "ntile",
          "null",
          "numeric",
          "of",
          "offset",
          "on",
          "only",
          "optimize",
          "optimizer_costs",
          "option",
          "optionally",
          "or",
          "order",
          "out",
          "outer",
          "outfile",
          "over",
          "partition",
          "percent_rank",
          "placing",
          "precision",
          "primary",
          "procedure",
          "purge",
          "range",
          "rank",
          "read_write",
          "read",
          "reads",
          "real",
          "recursive",
          "references",
          "regexp",
          "release",
          "rename",
          "repeat",
          "replace",
          "require",
          "resignal",
          "restrict",
          "return",
          "returning",
          "revoke",
          "right",
          "rlike",
          "row_number",
          "row",
          "rows",
          "schema",
          "schemas",
          "second_microsecond",
          "select",
          "sensitive",
          "separator",
          "session_user",
          "set",
          "show",
          "signal",
          "smallint",
          "some",
          "spatial",
          "specific",
          "sql_big_result",
          "sql_calc_found_rows",
          "sql_small_result",
          "sql",
          "sqlexception",
          "sqlstate",
          "sqlwarning",
          "ssl",
          "starting",
          "stored",
          "straight_join",
          "symmetric",
          "system",
          "table",
          "terminated",
          "then",
          "tinyblob",
          "tinyint",
          "tinytext",
          "to",
          "trailing",
          "trigger",
          "true",
          "undo",
          "union",
          "unique",
          "unlock",
          "unsigned",
          "update",
          "usage",
          "use",
          "user",
          "using",
          "utc_date",
          "utc_time",
          "utc_timestamp",
          "varbinary",
          "varchar",
          "varcharacter",
          "variadic",
          "varying",
          "virtual",
          "when",
          "where",
          "while",
          "window",
          "with",
          "write",
          "xor",
          "year_month",
          "zerofill");

  // Oracle 12.1c / 12.2c / 18c / 19c / 21c
  private static final Set<String> RESERVED_ORACLE =
      Set.of(
          "access",
          "add",
          "all",
          "alter",
          "and",
          "any",
          "as",
          "asc",
          "audit",
          "between",
          "by",
          "char",
          "check",
          "cluster",
          "column",
          "column_value",
          "comment",
          "compress",
          "connect",
          "create",
          "current",
          "date",
          "decimal",
          "default",
          "delete",
          "desc",
          "distinct",
          "drop",
          "else",
          "exclusive",
          "exists",
          "file",
          "float",
          "for",
          "from",
          "grant",
          "group",
          "having",
          "identified",
          "immediate",
          "in",
          "increment",
          "index",
          "initial",
          "insert",
          "integer",
          "intersect",
          "into",
          "is",
          "level",
          "like",
          "lock",
          "long",
          "maxextents",
          "minus",
          "mlslabel",
          "mode",
          "modify",
          "nested_table_id",
          "noaudit",
          "nocompress",
          "not",
          "nowait",
          "null",
          "number",
          "of",
          "offline",
          "on",
          "online",
          "option",
          "or",
          "order",
          "pctfree",
          "prior",
          "public",
          "raw",
          "rename",
          "resource",
          "revoke",
          "row",
          "rowid",
          "rownum",
          "rows",
          "select",
          "session",
          "set",
          "share",
          "size",
          "smallint",
          "start",
          "successful",
          "synonym",
          "sysdate",
          "table",
          "then",
          "to",
          "trigger",
          "uid",
          "union",
          "unique",
          "update",
          "user",
          "validate",
          "values",
          "varchar",
          "varchar2",
          "view",
          "whenever",
          "where",
          "with");
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\Overridable.java

package com.springforge.codegen.code.entity.model;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.function.BiConsumer;

@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Overridable {

  /**
   * Returns class for checking whether the attribute is overridable.
   *
   * @return override checker
   */
  Class<? extends BiConsumer<Object, Object>> value() default DefaultOverridable.class;
}

class DefaultOverridable implements BiConsumer<Object, Object> {
  @Override
  public void accept(Object t, Object u) {
    // Always allow
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\package-info.java
@jakarta.xml.bind.annotation.XmlAccessorType(jakarta.xml.bind.annotation.XmlAccessType.FIELD)
@jakarta.xml.bind.annotation.XmlSchema(
        namespace = "http://springforge.com/xml/ns/domain-models",
        elementFormDefault = jakarta.xml.bind.annotation.XmlNsForm.QUALIFIED)
package com.springforge.codegen.code.entity.model;
// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\Property.java

package com.springforge.codegen.code.entity.model;

import static com.springforge.codegen.code.entity.model.Utils.*;

import com.springforge.common.Inflector;
import com.springforge.common.StringUtils;
import com.springforge.codegen.code.JavaAnnotation;
import com.springforge.codegen.code.JavaCode;
import com.springforge.codegen.code.JavaDoc;
import com.springforge.codegen.code.JavaField;
import com.springforge.codegen.code.JavaMethod;
import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlTransient;
import jakarta.xml.bind.annotation.XmlType;
import jakarta.xml.bind.annotation.XmlValue;

@XmlType
public abstract class Property {

  @Overridable @XmlValue private String content;

  @XmlAttribute(name = "name", required = true)
  private String name;

  @XmlTransient private PropertyType type;

  @XmlAttribute(name = "column")
  private String column;

  @Overridable
  @XmlAttribute(name = "title")
  private String title;

  @Overridable
  @XmlAttribute(name = "help")
  private String help;

  @Overridable
  @XmlAttribute(name = "required")
  private Boolean required;

  @Overridable
  @XmlAttribute(name = "readonly")
  private Boolean readonly;

  @Overridable
  @XmlAttribute(name = "hidden")
  private Boolean hidden;

  @Overridable(PersistedChecker.class)
  @XmlAttribute(name = "transient")
  private Boolean _transient;

  @Overridable
  @XmlAttribute(name = "default")
  private String _default;

  @Overridable
  @XmlAttribute(name = "unique")
  private Boolean unique;

  @XmlAttribute(name = "initParam")
  private Boolean initParam;

  @Overridable
  @XmlAttribute(name = "index")
  private String index;

  @Overridable
  @XmlAttribute(name = "massUpdate")
  private Boolean massUpdate;

  @Overridable
  @XmlAttribute(name = "copy")
  private Boolean copy;

  @Overridable(SameTargetChecker.class)
  @XmlAttribute(name = "ref")
  private String target;

  @XmlAttribute(name = "mappedBy")
  private String mappedBy;

  @Overridable
  @XmlAttribute(name = "orphanRemoval")
  private Boolean orphanRemoval;

  @Overridable
  @XmlAttribute(name = "orderBy")
  private String orderBy;

  @XmlAttribute(name = "table")
  private String table;

  @XmlAttribute(name = "column2")
  private String column2;

  @Overridable
  @XmlAttribute(name = "nullable")
  private Boolean nullable;

  @Overridable
  @XmlAttribute(name = "selection")
  private String selection;

  @Overridable
  @XmlAttribute(name = "equalsInclude")
  private Boolean equalsInclude;

  @Overridable(PersistedChecker.class)
  @XmlAttribute(name = "formula")
  private Boolean formula;

  @Overridable
  @XmlAttribute(name = "min")
  private String min;

  @Overridable
  @XmlAttribute(name = "max")
  private String max;

  @Overridable
  @XmlAttribute(name = "precision")
  private Integer precision;

  @Overridable
  @XmlAttribute(name = "scale")
  private Integer scale;

  @Overridable
  @XmlAttribute(name = "image")
  private Boolean image;

  @Overridable
  @XmlAttribute(name = "encrypted")
  private Boolean encrypted;

  @XmlAttribute(name = "tz")
  private Boolean tz;

  @Overridable
  @XmlAttribute(name = "multiline")
  private Boolean multiline;

  @Overridable(LargeChecker.class)
  @XmlAttribute(name = "large")
  private Boolean large;

  @Overridable
  @XmlAttribute(name = "namecolumn")
  private Boolean nameField;

  @Overridable
  @XmlAttribute(name = "search")
  private String search;

  @XmlAttribute(name = "json")
  private Boolean json;

  @Overridable
  @XmlAttribute(name = "password")
  private Boolean password;

  @Overridable
  @XmlAttribute(name = "sequence")
  private String sequence;

  @Overridable
  @XmlAttribute(name = "translatable")
  private Boolean translatable;

  @Overridable @XmlAttribute private Boolean insertable;

  @Overridable @XmlAttribute private Boolean updatable;

  private static class LargeChecker implements BiConsumer<Object, Object> {
    @Override
    public void accept(Object a, Object b) {
      if (isTrue((Boolean) a) && isFalse((Boolean) b)) {
        throw new IllegalArgumentException("large field cannot become non-large");
      }
    }
  }

  private static class PersistedChecker implements BiConsumer<Object, Object> {
    @Override
    public void accept(Object a, Object b) {
      if (notTrue((Boolean) a) && isTrue((Boolean) b)) {
        throw new IllegalArgumentException("persisted field cannot become non-persisted");
      }
    }
  }

  private static class SameTargetChecker implements BiConsumer<Object, Object> {
    @Override
    public void accept(Object a, Object b) {
      String first = String.valueOf(a);
      String second = String.valueOf(b);
      final int firstIndex = first.lastIndexOf('.');
      final int secondIndex = second.lastIndexOf('.');
      if (firstIndex >= 0 || secondIndex >= 0) {
        first = first.substring(firstIndex + 1);
        second = second.substring(secondIndex + 1);
      }
      if (!Objects.equals(first, second)) {
        throw new IllegalArgumentException("cannot change reference entity");
      }
    }
  }

  private static List<PropertyAttribute> attributes = null;

  public static List<PropertyAttribute> getAttributes() {
    if (attributes != null) {
      return attributes;
    }

    final BeanInfo beanInfo;
    try {
      beanInfo = Introspector.getBeanInfo(Property.class);
    } catch (IntrospectionException e) {
      throw new RuntimeException(e);
    }

    final Map<String, PropertyDescriptor> descriptors =
        Arrays.stream(beanInfo.getPropertyDescriptors())
            .collect(
                Collectors.toUnmodifiableMap(PropertyDescriptor::getName, Function.identity()));
    final BiConsumer<Object, Object> notOverridable =
        (a, b) -> {
          throw new IllegalArgumentException("this attribute is not overridable");
        };
    final Map<Class<? extends BiConsumer<Object, Object>>, BiConsumer<Object, Object>>
        checkOverrides = new HashMap<>();

    attributes =
        Arrays.stream(Property.class.getDeclaredFields())
            .filter(
                field ->
                    field.isAnnotationPresent(XmlAttribute.class)
                        || field.isAnnotationPresent(XmlValue.class))
            .map(
                field -> {
                  final String fieldName = field.getName().replaceAll("(?:^_+)|(?:_+$)", "");
                  final String attributeName =
                      Optional.ofNullable(field.getAnnotation(XmlAttribute.class))
                          .map(XmlAttribute::name)
                          .filter(name -> !name.startsWith("#"))
                          .orElse(fieldName);
                  final Overridable overridableAnnotation = field.getAnnotation(Overridable.class);
                  final BiConsumer<Object, Object> checkOverride =
                      overridableAnnotation == null
                          ? notOverridable
                          : checkOverrides.computeIfAbsent(
                              overridableAnnotation.value(),
                              cls -> {
                                try {
                                  return cls.getDeclaredConstructor().newInstance();
                                } catch (ReflectiveOperationException e) {
                                  throw new RuntimeException(e);
                                }
                              });

                  if (field.isAnnotationPresent(XmlValue.class)) {
                    return PropertyAttribute.ofValue(
                        attributeName, descriptors.get(fieldName), checkOverride);
                  }

                  return PropertyAttribute.of(
                      attributeName, descriptors.get(fieldName), checkOverride);
                })
            .collect(Collectors.toUnmodifiableList());

    return attributes;
  }

  protected Property() {
    this.type =
        PropertyType.valueOf(
            getClass().getAnnotation(XmlType.class).name().toUpperCase().replace('-', '_'));
  }

  public String getContent() {
    return content;
  }

  public void setContent(String value) {
    this.content = value;
  }

  public String getName() {
    return name;
  }

  public void setName(String value) {
    this.name = value;
  }

  public PropertyType getType() {
    return type;
  }

  public void setType(PropertyType type) {
    this.type = type;
  }

  public String getJavaType() {
    if (type == PropertyType.STRING) return "String";
    if (type == PropertyType.INTEGER) return "Integer";
    if (type == PropertyType.LONG) return "Long";
    if (type == PropertyType.BOOLEAN) return "Boolean";
    if (type == PropertyType.DECIMAL) return "java.math.BigDecimal";
    if (type == PropertyType.DATE) return "java.time.LocalDate";
    if (type == PropertyType.TIME) return "java.time.LocalTime";
    if (type == PropertyType.DATETIME && isTrue(tz)) return "java.time.ZonedDateTime";
    if (type == PropertyType.DATETIME) return "java.time.LocalDateTime";
    if (type == PropertyType.BINARY) return "byte[]";
    if (type == PropertyType.ENUM) return target;
    if (type == PropertyType.ONE_TO_ONE) return target;
    if (type == PropertyType.MANY_TO_ONE) return target;
    if (type == PropertyType.ONE_TO_MANY) return String.format("java.util.List<%s>", target);
    if (type == PropertyType.MANY_TO_MANY) return String.format("java.util.Set<%s>", target);
    return null;
  }

  public String getColumn() {
    return column;
  }

  public void setColumn(String value) {
    this.column = value;
  }

  public String getTitle() {
    return title;
  }

  public void setTitle(String value) {
    this.title = value;
  }

  public String getHelp() {
    return help;
  }

  public void setHelp(String value) {
    this.help = value;
  }

  public Boolean getRequired() {
    return required;
  }

  public void setRequired(Boolean value) {
    this.required = value;
  }

  public Boolean getReadonly() {
    return readonly;
  }

  public void setReadonly(Boolean value) {
    this.readonly = value;
  }

  public Boolean getHidden() {
    return hidden;
  }

  public void setHidden(Boolean value) {
    this.hidden = value;
  }

  public Boolean getTransient() {
    return _transient;
  }

  public void setTransient(Boolean value) {
    this._transient = value;
  }

  public String getDefault() {
    return _default;
  }

  public void setDefault(String value) {
    this._default = value;
  }

  public Boolean getUnique() {
    return unique;
  }

  public void setUnique(Boolean value) {
    this.unique = value;
  }

  public Boolean getInitParam() {
    return initParam;
  }

  public void setInitParam(Boolean value) {
    this.initParam = value;
  }

  public String getIndex() {
    return index;
  }

  public void setIndex(String value) {
    this.index = value;
  }

  public Boolean getMassUpdate() {
    return massUpdate;
  }

  public void setMassUpdate(Boolean value) {
    this.massUpdate = value;
  }

  public Boolean getCopy() {
    return copy;
  }

  public void setCopy(Boolean value) {
    this.copy = value;
  }

  public String getTarget() {
    return target;
  }

  public void setTarget(String value) {
    this.target = value;
  }

  public String getMappedBy() {
    return mappedBy;
  }

  public void setMappedBy(String value) {
    this.mappedBy = value;
  }

  public Boolean getOrphanRemoval() {
    if (orphanRemoval != null) {
      return orphanRemoval;
    }
    // if not specified, orphanRemoval is considered as true in case of bidirectional O2M
    return notBlank(mappedBy) && type == PropertyType.ONE_TO_MANY;
  }

  public void setOrphanRemoval(Boolean value) {
    this.orphanRemoval = value;
  }

  public String getOrderBy() {
    return orderBy;
  }

  public void setOrderBy(String value) {
    this.orderBy = value;
  }

  public String getTable() {
    return table;
  }

  public void setTable(String value) {
    this.table = value;
  }

  public String getColumn2() {
    return column2;
  }

  public void setColumn2(String value) {
    this.column2 = value;
  }

  public Boolean getNullable() {
    return nullable;
  }

  public void setNullable(Boolean value) {
    this.nullable = value;
  }

  public String getSelection() {
    return selection;
  }

  public void setSelection(String value) {
    this.selection = value;
  }

  public Boolean getEqualsInclude() {
    return equalsInclude;
  }

  public void setEqualsInclude(Boolean equalsInclude) {
    this.equalsInclude = equalsInclude;
  }

  public Boolean getFormula() {
    return formula;
  }

  public void setFormula(Boolean value) {
    this.formula = value;
  }

  public String getMin() {
    return min;
  }

  public void setMin(String value) {
    this.min = value;
  }

  public String getMax() {
    return max;
  }

  public void setMax(String value) {
    this.max = value;
  }

  public Integer getPrecision() {
    return precision;
  }

  public void setPrecision(Integer value) {
    this.precision = value;
  }

  public Integer getScale() {
    return scale;
  }

  public void setScale(Integer value) {
    this.scale = value;
  }

  public Boolean getImage() {
    return image;
  }

  public void setImage(Boolean value) {
    this.image = value;
  }

  public Boolean getMultiline() {
    return multiline;
  }

  public void setMultiline(Boolean value) {
    this.multiline = value;
  }

  public Boolean getLarge() {
    return large;
  }

  public void setLarge(Boolean value) {
    this.large = value;
  }

  public Boolean getNameField() {
    return nameField;
  }

  public void setNameField(Boolean value) {
    this.nameField = value;
  }

  public String getSearch() {
    return search;
  }

  public void setSearch(String value) {
    this.search = value;
  }

  public Boolean getJson() {
    return json;
  }

  public void setJson(Boolean value) {
    this.json = value;
  }

  public Boolean getPassword() {
    return password;
  }

  public void setPassword(Boolean value) {
    this.password = value;
  }

  public String getSequence() {
    return sequence;
  }

  public void setSequence(String value) {
    this.sequence = value;
  }

  public Boolean getTranslatable() {
    return translatable;
  }

  public void setTranslatable(Boolean value) {
    this.translatable = value;
  }

  public Boolean getInsertable() {
    return insertable;
  }

  public void setInsertable(Boolean insertable) {
    this.insertable = insertable;
  }

  public Boolean getUpdatable() {
    return updatable;
  }

  public void setUpdatable(Boolean updatable) {
    this.updatable = updatable;
  }

  public Boolean getEncrypted() {
    return encrypted;
  }

  public void setEncrypted(Boolean value) {
    this.encrypted = value;
  }

  public Boolean getTz() {
    return tz;
  }

  public void setTz(Boolean value) {
    this.tz = value;
  }

  public boolean isPrimary() {
    return "id".equals(name);
  }

  public boolean isVersion() {
    return "version".equals(name);
  }

  public boolean isSimple() {
    return !(isCollection() || isReference() || isEnum() || isBinary() || isTrue(large));
  }

  public boolean isVirtual() {
    return notBlank(content);
  }

  public boolean isCollection() {
    return type == PropertyType.ONE_TO_MANY || type == PropertyType.MANY_TO_MANY;
  }

  public boolean isReference() {
    return type == PropertyType.MANY_TO_ONE || type == PropertyType.ONE_TO_ONE;
  }

  public boolean isEnum() {
    return type == PropertyType.ENUM;
  }

  public boolean isBinary() {
    return type == PropertyType.BINARY;
  }

  public boolean isIndexable() {
    if (isTrue(unique) || isTrue(formula) || isTrue(_transient) || "false".equals(index)) {
      return false;
    }
    return isTrue(nameField)
        || "name".equals(name)
        || "code".equals(name)
        || (index != null && index.matches("^(true|idx_.*)"))
        || (isReference() && isBlank(mappedBy));
  }

  public Index createIndex() {
    if (isIndexable()) {
      String indexName = index;
      String columnName = getColumn();
      if ("true".equals(indexName)) indexName = null;
      if (columnName == null && isReference()) columnName = getColumnAuto();
      if (columnName == null) columnName = name;

      Index idx = new Index();
      idx.setName(indexName);
      idx.setColumns(columnName);

      return idx;
    }
    return null;
  }

  public String getSingularName() {
    return name.endsWith("Set") || name.endsWith("List")
        ? name + "Item"
        : Inflector.getInstance().singularize(name);
  }

  public String getColumnAuto() {
    String col = getColumn();
    if (notBlank(col)) {
      return col;
    }
    // follow hibernate naming
    final StringBuilder buf = new StringBuilder(name.replace('.', '_'));
    for (int i = 1; i < buf.length() - 1; i++) {
      if (Character.isLowerCase(buf.charAt(i - 1))
          && Character.isUpperCase(buf.charAt(i))
          && Character.isLowerCase(buf.charAt(i + 1))) {
        buf.insert(i++, '_');
      }
    }
    return buf.toString().toLowerCase();
  }

  private JavaCode getDefaultValue() {
    if (isPrimary()) {
      return null;
    }

    final String value = getDefault();
    final String empty = getEmptyValue();

    if (value == null) {
      return empty == null ? null : new JavaCode("{0:l}", empty);
    } else if (isBlank(value)) {
      return null;
    }

    if (type == PropertyType.BOOLEAN) {
      if (value.matches("true|t|1|Boolean\\.TRUE")) {
        return new JavaCode("{0:l}", "Boolean.TRUE");
      }
      return !isTrue(nullable) || value.matches("false|f|0|Boolean\\\\.FALSE")
          ? new JavaCode("{0:l}", "Boolean.FALSE")
          : new JavaCode("{0:l}", "null");
    }

    if (type == PropertyType.STRING) {
      return new JavaCode("{0:s}", value);
    }

    if (type == PropertyType.LONG) {
      return value.toLowerCase().endsWith("l")
          ? new JavaCode("{0:l}", value)
          : new JavaCode("{0:l}L", value);
    }

    if (type == PropertyType.INTEGER) {
      return new JavaCode("{0:l}", value);
    }

    if (type == PropertyType.DECIMAL) {
      return new JavaCode("new BigDecimal({0:s})", value);
    }

    if (type == PropertyType.DATE) {
      return "now".equals(value)
          ? new JavaCode("LocalDate.now()")
          : new JavaCode("LocalDate.parse({0:s})", value);
    }

    if (type == PropertyType.TIME) {
      return "now".equals(value)
          ? new JavaCode("LocalTime.now()")
          : new JavaCode("LocalTime.parse({0:s})", value);
    }

    if (type == PropertyType.DATETIME) {
      String dt = isTrue(tz) ? "ZonedDateTime" : "LocalDateTime";
      return "now".equals(value)
          ? new JavaCode("{0:t}.now()", dt)
          : new JavaCode("{0:t}.parse({1:s})", dt, value);
    }

    if (type == PropertyType.ENUM) {
      return new JavaCode("{0:m}", target + "." + value);
    }

    return null;
  }

  private String getEmptyValue() {
    if (isTrue(nullable)) return null;
    if (type == PropertyType.BOOLEAN) return "Boolean.FALSE";
    if (type == PropertyType.INTEGER) return "0";
    if (type == PropertyType.LONG) return "0L";
    if (type == PropertyType.DECIMAL) return "BigDecimal.ZERO";
    return null;
  }

  public JavaField toJavaField(Entity entity) {
    int modifiers = Modifier.PRIVATE;
    JavaField field = new JavaField(name, getJavaType(), modifiers).defaultValue(getDefaultValue());
    Stream.of(
            $id(entity),
            $equalsInclude(entity),
            $widget(),
            $binary(entity),
            $nameColumn(entity),
            $virtual(),
            $required(),
            $size(),
            $digits(),
            $transient(),
            $column(),
            $one2one(),
            $many2one(),
            $one2many(),
            $many2many(),
            $joinTable(),
            $orderBy(),
            $sequence(),
            $converter())
        .flatMap(x -> x instanceof Collection ? ((Collection<?>) x).stream() : Stream.of(x))
        .filter(Objects::nonNull)
        .map(JavaAnnotation.class::cast)
        .forEach(field::annotation);
    return field;
  }

  public List<JavaMethod> toJavaMethods() {
    return Arrays.asList(
            createGetterMethod(),
            createComputeMethod(),
            createSetterMethod(),
            createAddMethod(),
            createRemoveMethod(),
            createClearMethod())
        .stream()
        .filter(Objects::nonNull)
        .collect(Collectors.toList());
  }

  private List<JavaAnnotation> $id(Entity entity) {
    if (!isPrimary()) {
      return null;
    }

    if (isFalse(entity.getSequential()) || isTrue(entity.getMappedSuperClass())) {
      return List.of(
          new JavaAnnotation("jakarta.persistence.Id"),
          new JavaAnnotation("jakarta.persistence.GeneratedValue")
              .param("strategy", "{0:m}", "jakarta.persistence.GenerationType.AUTO"));
    }

    String name = entity.getTable() + "_SEQ";

    return List.of(
        new JavaAnnotation("jakarta.persistence.Id"),
        new JavaAnnotation("jakarta.persistence.GeneratedValue")
            .param("strategy", "{0:m}", "jakarta.persistence.GenerationType.SEQUENCE")
            .param("generator", "{0:s}", name),
        new JavaAnnotation("jakarta.persistence.SequenceGenerator")
            .param("name", "{0:s}", name)
            .param("sequenceName", "{0:s}", name)
            .param("allocationSize", "{0:l}", 1));
  }

  private JavaAnnotation $equalsInclude(Entity entity) {
    if (isPrimary() || isVersion()) return null;
    if (isFalse(equalsInclude)) return null;
    if (isTrue(equalsInclude)
        || isTrue(unique)
        || (isTrue(entity.getEqualsAll()) && isSimple() && !isVirtual())) {
      return new JavaAnnotation("com.springforge.db.annotations.EqualsInclude");
    }
    return null;
  }

  private JavaAnnotation $widget() {

    if (isTrue(massUpdate) && (isTrue(unique) || isCollection() || isTrue(large))) {
      massUpdate = false;
    }

    if (notBlank(selection)) {
      selection = selection.replaceAll("\\],\\s*\\[", "], [");
    }

    JavaAnnotation widget = new JavaAnnotation("com.springforge.db.annotations.Widget");

    Map<String, JavaCode> params = new HashMap<>();
    BiFunction<String, Object, JavaCode> value = (s, v) -> v == null ? null : new JavaCode(s, v);

    params.put("image", value.apply("{0:l}", image));
    params.put("title", value.apply("{0:s}", title));
    params.put("help", value.apply("{0:s}", help));
    params.put("readonly", value.apply("{0:l}", readonly));
    params.put("hidden", value.apply("{0:l}", hidden));
    params.put("multiline", value.apply("{0:l}", multiline));
    params.put("search", value.apply("{0:a}", search));
    params.put("selection", value.apply("{0:s}", selection));
    params.put("password", value.apply("{0:l}", password));
    params.put("massUpdate", value.apply("{0:l}", massUpdate));
    params.put("translatable", value.apply("{0:l}", translatable));
    params.put("copyable", value.apply("{0:l}", copy));
    params.put("defaultNow", value.apply("{0:l}", "now".equals(getDefault()) ? "true" : null));

    params.values().removeIf(Objects::isNull);

    if (params.isEmpty()) {
      return null;
    }

    params.entrySet().stream().forEach(e -> widget.param(e.getKey(), e.getValue()));

    return widget;
  }

  private List<JavaAnnotation> $binary(Entity entity) {

    if (isTrue(json) && type == PropertyType.STRING) {
      if (isTrue(encrypted)) {
        throw new IllegalArgumentException(
            String.format(
                "Encryption is not supported on json field: %s.%s", entity.getName(), name));
      }
      return List.of(
          new JavaAnnotation("jakarta.persistence.Basic")
              .param("fetch", "{0:m}", "jakarta.persistence.FetchType.LAZY"),
          new JavaAnnotation("org.hibernate.annotations.Type").param("type", "{0:s}", "json"));
    }

    if (type == PropertyType.ENUM) {
      return List.of(
          new JavaAnnotation("jakarta.persistence.Basic"),
          new JavaAnnotation("org.hibernate.annotations.Type")
              .param("type", "{0:s}", "com.springforge.db.hibernate.type.ValueEnumType"));
    }

    if (isTrue(large) && type == PropertyType.STRING) {
      return List.of(
          new JavaAnnotation("jakarta.persistence.Lob"),
          new JavaAnnotation("jakarta.persistence.Basic")
              .param("fetch", "{0:m}", "jakarta.persistence.FetchType.LAZY"),
          new JavaAnnotation("org.hibernate.annotations.Type")
              .param("type", "{0:s}", isTrue(encrypted) ? "encrypted_text" : "text"));
    }

    if (isTrue(large) || type == PropertyType.BINARY) {
      return List.of(
          new JavaAnnotation("jakarta.persistence.Lob"),
          new JavaAnnotation("jakarta.persistence.Basic")
              .param("fetch", "{0:m}", "jakarta.persistence.FetchType.LAZY"));
    }

    return null;
  }

  private JavaAnnotation $nameColumn(Entity entity) {
    if (isTrue(nameField)
        && (entity == null || entity.getNameField() == null || entity.getNameField() == this)) {
      return new JavaAnnotation("com.springforge.db.annotations.NameColumn");
    }
    return null;
  }

  private List<JavaAnnotation> $virtual() {
    if (!isVirtual() || isBlank(content)) {
      return null;
    }

    List<JavaAnnotation> all = new ArrayList<>();

    all.add(new JavaAnnotation("com.springforge.db.annotations.VirtualColumn"));

    if (isTrue(_transient)) {
      return all;
    }

    if (isTrue(formula)) {

      String text = content;

      text = StringUtils.stripIndent(text); // remove extra indentation
      text = text.replaceAll("(?:^\\s+)|(?:\\s+$)", ""); // remove leading/trailing spaces
      text = text.replaceAll("\"", "\\\\\\\\\""); // escape quotes
      text = text.replaceAll("\n", "\\\\\\\\n\" + \n  \""); // concat multi-line formular
      text = "\"(" + text + ")\"";

      all.add(
          new JavaAnnotation(
                  isReference()
                      ? "org.hibernate.annotations.JoinFormula"
                      : "org.hibernate.annotations.Formula")
              .param("value", "{0:l}", text));
    } else {
      all.add(
          new JavaAnnotation("jakarta.persistence.Access")
              .param("value", "{0:m}", "jakarta.persistence.AccessType.PROPERTY"));
    }

    return all;
  }

  private JavaAnnotation $required() {
    return isTrue(required) ? new JavaAnnotation("jakarta.validation.constraints.NotNull") : null;
  }

  private List<JavaAnnotation> $size() {

    if (isBlank(min) && isBlank(max)) {
      return null;
    }

    final List<JavaAnnotation> all = new ArrayList<>();

    if (type == PropertyType.DECIMAL) {
      if (notBlank(min))
        all.add(
            new JavaAnnotation("jakarta.validation.constraints.DecimalMin")
                .param("value", "{0:s}", min));
      if (notBlank(max))
        all.add(
            new JavaAnnotation("jakarta.validation.constraints.DecimalMax")
                .param("value", "{0:s}", max));
      return all;
    }

    if (type == PropertyType.STRING) {
      if (isTrue(encrypted) && notBlank(max) && Integer.valueOf(max) < 256) {
        throw new IllegalArgumentException("Encrypted field size should be more than 255.");
      }
      all.add(
          new JavaAnnotation("jakarta.validation.constraints.Size")
              .param("min", min)
              .param("max", max));
      return all;
    }

    if (notBlank(min))
      all.add(new JavaAnnotation("jakarta.validation.constraints.Min").param("value", min));
    if (notBlank(max))
      all.add(new JavaAnnotation("jakarta.validation.constraints.Max").param("value", max));

    return all;
  }

  private JavaAnnotation $digits() {

    if (precision == null && scale == null) {
      return null;
    }

    if (precision == null) {
      throw new IllegalArgumentException(
          "Invalid use of 'scale' without 'precision' on field: " + name);
    }

    if (scale == null) {
      throw new IllegalArgumentException(
          "Invalid use of 'precision' without 'scale' on field: " + name);
    }

    if (scale > precision) {
      throw new IllegalArgumentException(
          "Invalid 'scale' value, should be less than 'precision' on field: " + name);
    }

    return new JavaAnnotation("jakarta.validation.constraints.Digits")
        .param("integer", "{0:l}", precision - scale)
        .param("fraction", "{0:l}", scale);
  }

  private JavaAnnotation $transient() {
    return isTrue(getTransient()) ? new JavaAnnotation("jakarta.persistence.Transient") : null;
  }

  private JavaAnnotation $column() {
    if (Naming.isReserved(name)) {
      throw new IllegalArgumentException("Invalid use of a reserved name: " + name);
    }

    if (isCollection()) {
      return null;
    }

    String col = getColumnAuto();
    if (Naming.isKeyword(col)) {
      throw new IllegalArgumentException("Invalid use of an SQL keyword: " + col);
    }

    if (column == null
        && unique == null
        && nullable == null
        && insertable == null
        && updatable == null) {
      return null;
    }

    JavaAnnotation res =
        new JavaAnnotation(
            isReference() ? "jakarta.persistence.JoinColumn" : "jakarta.persistence.Column");

    if (column != null) {
      res.param("name", "{0:s}", column);
    }

    if (unique != null) {
      res.param("unique", "{0:l}", unique);
    }

    if (nullable != null) {
      res.param("nullable", "{0:l}", nullable);
    }

    if (insertable != null) {
      res.param("insertable", "{0:l}", insertable);
    }

    if (updatable != null) {
      res.param("updatable", "{0:l}", updatable);
    }

    return res;
  }

  private JavaAnnotation $one2one() {
    if (type != PropertyType.ONE_TO_ONE) return null;

    JavaAnnotation annotation =
        new JavaAnnotation("jakarta.persistence.OneToOne")
            .param("fetch", "{0:m}", "jakarta.persistence.FetchType.LAZY");

    if (mappedBy != null) {
      annotation.param("mappedBy", "{0:s}", mappedBy);
    }

    if (isTrue(getOrphanRemoval())) {
      annotation.param("cascade", "{0:m}", "jakarta.persistence.CascadeType.ALL");
      annotation.param("orphanRemoval", "true");
    } else {
      annotation.param(
          "cascade",
          List.of("jakarta.persistence.CascadeType.PERSIST", "jakarta.persistence.CascadeType.MERGE"),
          t -> new JavaCode("{0:m}", t));
    }
    return annotation;
  }

  private JavaAnnotation $many2one() {
    if (type != PropertyType.MANY_TO_ONE) return null;

    return new JavaAnnotation("jakarta.persistence.ManyToOne")
        .param("fetch", "{0:m}", "jakarta.persistence.FetchType.LAZY")
        .param(
            "cascade",
            List.of("jakarta.persistence.CascadeType.PERSIST", "jakarta.persistence.CascadeType.MERGE"),
            t -> new JavaCode("{0:m}", t));
  }

  private JavaAnnotation $one2many() {
    if (type != PropertyType.ONE_TO_MANY) return null;

    JavaAnnotation annotation =
        new JavaAnnotation("jakarta.persistence.OneToMany")
            .param("fetch", "{0:m}", "jakarta.persistence.FetchType.LAZY");

    if (mappedBy != null) {
      annotation.param("mappedBy", "{0:s}", mappedBy);
    }

    if (isTrue(getOrphanRemoval())) {
      annotation.param("cascade", "{0:m}", "jakarta.persistence.CascadeType.ALL");
      annotation.param("orphanRemoval", "true");
    } else {
      annotation.param(
          "cascade",
          List.of("jakarta.persistence.CascadeType.PERSIST", "jakarta.persistence.CascadeType.MERGE"),
          t -> new JavaCode("{0:m}", t));
    }

    return annotation;
  }

  private JavaAnnotation $many2many() {
    if (type != PropertyType.MANY_TO_MANY) return null;

    JavaAnnotation annotation =
        new JavaAnnotation("jakarta.persistence.ManyToMany")
            .param("fetch", "{0:m}", "jakarta.persistence.FetchType.LAZY");

    if (mappedBy != null) {
      annotation.param("mappedBy", "{0:s}", mappedBy);
    }

    annotation.param(
        "cascade",
        List.of("jakarta.persistence.CascadeType.PERSIST", "jakarta.persistence.CascadeType.MERGE"),
        t -> new JavaCode("{0:m}", t));

    return annotation;
  }

  private JavaAnnotation $joinTable() {

    String joinTable = table;
    String fk1 = column;
    String fk2 = column2;

    if (joinTable == null) {
      return null;
    }

    JavaAnnotation annotation =
        new JavaAnnotation("jakarta.persistence.JoinTable").param("name", "{0:s}", joinTable);

    if (fk1 != null) {
      annotation.param(
          "joinColumns",
          new JavaAnnotation("jakarta.persistence.JoinColumn").param("name", "{0:s}", fk1));
    }

    if (fk2 != null) {
      annotation.param(
          "inverseJoinColumns",
          new JavaAnnotation("jakarta.persistence.JoinColumn").param("name", "{0:s}", fk2));
    }

    return annotation;
  }

  private JavaAnnotation $orderBy() {
    if (isBlank(orderBy)) return null;

    return new JavaAnnotation("jakarta.persistence.OrderBy")
        .param("value", "{0:s}", orderBy.replaceAll("-\\s*(\\w+)", "$1 DESC"));
  }

  private JavaAnnotation $sequence() {
    return isBlank(sequence)
        ? null
        : new JavaAnnotation("com.springforge.db.annotations.Sequence")
            .param("value", "{0:s}", sequence);
  }

  private JavaAnnotation $converter() {
    if (notTrue(encrypted) || isTrue(large)) return null;

    String converter =
        isBinary()
            ? "com.springforge.db.converters.EncryptedBytesConverter"
            : "com.springforge.db.converters.EncryptedStringConverter";
    return new JavaAnnotation("jakarta.persistence.Convert")
        .param("converter", "{0:t}.class", converter);
  }

  private JavaMethod createGetterMethod() {
    final String methodName = getterName(name);
    final String computeName = methodName("compute", name);

    final JavaMethod method = new JavaMethod(methodName, getJavaType(), Modifier.PUBLIC);

    if (isVirtual() && notTrue(formula)) {
      method.code("try {");
      method.code("  {0:l} = {1:l}();", name, computeName);
      method.code("} catch (NullPointerException e) {");
      method.code(
          "  {0:t} logger = {1:t}.getLogger(getClass());",
          "org.slf4j.Logger",
          "org.slf4j.LoggerFactory");
      method.code("  logger.error({0:s}, e);", "NPE in function field: " + methodName + "()");
      method.code("}");
      method.code("return {0:l};", name);
      return method;
    }

    if (isPrimary()) {
      method.code("return {0:l};", name);
      method.annotation(new JavaAnnotation("Override"));
      return method;
    }

    String empty = "".equals(getDefault()) ? null : this.getEmptyValue();

    if (notBlank(empty)) {
      method.code("return {0:l} == null ? {1:l} : {0:l};", name, empty);
    } else {
      method.code("return {0:l};", name);
    }

    if (notBlank(help)) {
      method.doc(new JavaDoc(help).returns("the property value"));
    }

    return method;
  }

  private JavaMethod createSetterMethod() {
    final String methodName = setterName(name);
    final String getterName = getterName(name);

    final JavaMethod method =
        new JavaMethod(methodName, "void", Modifier.PUBLIC).param(name, getJavaType());

    if (isPrimary()) {
      method.annotation(new JavaAnnotation("Override"));
    }

    if (notBlank(mappedBy) && type == PropertyType.ONE_TO_ONE) {
      method.code("if ({0:l}() != null) {", getterName);
      method.code("  {0:l}().{1:l}(null);", getterName, setterName(mappedBy));
      method.code("}");
      method.code("if ({0:l} != null) {", name);
      method.code("  {0:l}.{1:l}(this);", name, setterName(mappedBy));
      method.code("}");
    }

    method.code("this.{0:l} = {0:l};", name);

    return method;
  }

  private JavaMethod createComputeMethod() {
    if (isTrue(formula) || isBlank(content)) return null;

    final String methodName = methodName("compute", name);
    final JavaMethod method = new JavaMethod(methodName, getJavaType(), Modifier.PROTECTED);

    method.code(content.trim());

    return method;
  }

  private JavaMethod createAddMethod() {
    if (!isCollection()) return null;

    final String methodName = methodName("add", getSingularName());
    final String getterName = getterName(name);
    final String setterName = setterName(name);

    final JavaMethod method =
        new JavaMethod(methodName, "void", Modifier.PUBLIC).param("item", getTarget());

    final String collectionType =
        type == PropertyType.MANY_TO_MANY ? "java.util.HashSet" : "java.util.ArrayList";

    method.code("if ({0:l}() == null) {", getterName);
    method.code("  {0:l}(new {1:t}<>());", setterName, collectionType);
    method.code("}");
    method.code("{0:l}().add(item);", getterName);

    if (notBlank(mappedBy) && type == PropertyType.ONE_TO_MANY) {
      method.code("item.{0:l}(this);", setterName(mappedBy));
    }

    final JavaDoc doc =
        new JavaDoc(
            "Add the given {@link {0:t}} item to the {@code {1:l}} collection.", target, name);
    if (notBlank(mappedBy) && type == PropertyType.ONE_TO_MANY) {
      doc.line("<p>");
      doc.line("It sets {@code item.{0:l} = this} to ensure the proper relationship.", mappedBy);
      doc.line("</p>");
    }

    doc.param("item", "the item to add");

    return method.doc(doc);
  }

  private JavaMethod createRemoveMethod() {
    if (!isCollection()) return null;

    final String methodName = methodName("remove", getSingularName());
    final String getterName = getterName(name);

    final JavaMethod method =
        new JavaMethod(methodName, "void", Modifier.PUBLIC).param("item", getTarget());

    method.code("if ({0:l}() == null) {", getterName);
    method.code("  return;");
    method.code("}");
    method.code("{0:l}().remove(item);", getterName);

    if (notBlank(mappedBy) && notTrue(getOrphanRemoval()) && type == PropertyType.ONE_TO_MANY) {
      method.code("item.{0:l}(null);", setterName(mappedBy));
    }

    final JavaDoc doc =
        new JavaDoc(
            "Remove the given {@link {0:t}} item from the {@code {1:l}} collection.", target, name);
    if (notBlank(mappedBy) && notTrue(getOrphanRemoval()) && type == PropertyType.ONE_TO_MANY) {
      doc.line("<p>");
      doc.line("It sets {@code item.{0:l} = null} to break the relationship.", mappedBy);
      doc.line("</p>");
    }

    doc.param("item", "the item to remove");

    return method.doc(doc);
  }

  private JavaMethod createClearMethod() {
    if (!isCollection()) return null;

    final String methodName = methodName("clear", name);
    final String getterName = getterName(name);

    final JavaMethod method = new JavaMethod(methodName, "void", Modifier.PUBLIC);

    method.code("if ({0:l}() != null) {", getterName);

    if (notBlank(mappedBy) && notTrue(getOrphanRemoval()) && type == PropertyType.ONE_TO_MANY) {
      method.code("  {0:l}().forEach(item -> item.{1:l}(null));", getterName, setterName(mappedBy));
    }

    method.code("  {0:l}().clear();", getterName);
    method.code("}");

    final JavaDoc doc = new JavaDoc("Clear the {@code {0:l}} collection.", name);

    if (notBlank(mappedBy) && notTrue(getOrphanRemoval()) && type == PropertyType.ONE_TO_MANY) {
      doc.line("<p>");
      doc.line("It sets {@code item.{0:l} = null} to break the relationship.", mappedBy);
      doc.line("</p>");
      doc.line("<p>");
      doc.line("If you have to query {@link {0:t}} records in same transaction, make", target);
      doc.line("sure to call {@link jakarta.persistence.EntityManager#flush() } to avoid");
      doc.line("unexpected errors.");
      doc.line("</p>");
    }

    return method.doc(doc);
  }

  @XmlType(name = "string")
  static class StringProperty extends Property {}

  @XmlType(name = "boolean")
  static class BooleanProperty extends Property {}

  @XmlType(name = "integer")
  static class IntegerProperty extends Property {}

  @XmlType(name = "long")
  static class LongProperty extends Property {}

  @XmlType(name = "decimal")
  static class DecimalProperty extends Property {}

  @XmlType(name = "date")
  static class DateProperty extends Property {}

  @XmlType(name = "time")
  static class TimeProperty extends Property {}

  @XmlType(name = "datetime")
  static class DateTimeProperty extends Property {}

  @XmlType(name = "binary")
  static class BinaryProperty extends Property {}

  @XmlType(name = "enum")
  static class EnumProperty extends Property {}

  @XmlType(name = "one-to-one")
  static class OneToOneProperty extends Property {}

  @XmlType(name = "many-to-one")
  static class ManyToOneProperty extends Property {}

  @XmlType(name = "one-to-many")
  static class OneToManyProperty extends Property {}

  @XmlType(name = "many-to-many")
  static class ManyToManyProperty extends Property {}
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\PropertyAttribute.java

package com.springforge.codegen.code.entity.model;

import com.springforge.common.StringUtils;
import com.google.common.base.Preconditions;
import java.beans.PropertyDescriptor;
import java.util.Objects;
import java.util.function.BiConsumer;
import java.util.function.Predicate;

public class PropertyAttribute {
  private final String name;
  private final PropertyDescriptor descriptor;

  private final BiConsumer<Object, Object> checkOverride;
  private final Predicate<Object> isAbsent;

  public static PropertyAttribute of(
      String name, PropertyDescriptor descriptor, BiConsumer<Object, Object> checkOverride) {
    return new PropertyAttribute(name, descriptor, checkOverride, Objects::isNull);
  }

  public static PropertyAttribute ofValue(
      String name, PropertyDescriptor descriptor, BiConsumer<Object, Object> checkOverride) {
    return new PropertyAttribute(
        name, descriptor, checkOverride, value -> StringUtils.isBlank(String.valueOf(value)));
  }

  private PropertyAttribute(
      String name,
      PropertyDescriptor descriptor,
      BiConsumer<Object, Object> checkOverride,
      Predicate<Object> isAbsent) {
    Preconditions.checkNotNull(descriptor);
    this.name = StringUtils.notBlank(name) ? name : descriptor.getName();
    this.descriptor = descriptor;
    this.checkOverride = checkOverride != null ? checkOverride : (a, b) -> {};
    this.isAbsent = isAbsent;
  }

  public String getName() {
    return name;
  }

  public PropertyDescriptor getDescriptor() {
    return descriptor;
  }

  public void checkOverride(Object a, Object b) {
    checkOverride.accept(a, b);
  }

  public boolean isAbsent(Object a) {
    return isAbsent.test(a);
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\PropertyType.java

package com.springforge.codegen.code.entity.model;

public enum PropertyType {
  STRING,

  BOOLEAN,

  INTEGER,

  LONG,

  DECIMAL,

  DATE,

  TIME,

  DATETIME,

  BINARY,

  ENUM,

  ONE_TO_ONE,

  MANY_TO_ONE,

  ONE_TO_MANY,

  MANY_TO_MANY
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\Track.java
package com.springforge.codegen.code.entity.model;

import static com.springforge.codegen.code.entity.model.Utils.isTrue;

import com.springforge.codegen.code.JavaAnnotation;
import java.util.ArrayList;
import java.util.List;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlType;

@XmlType
public class Track {

  @XmlElement(name = "field")
  private List<TrackField> fields;

  @XmlElement(name = "message")
  private List<TrackMessage> messages;

  @XmlElement(name = "content")
  private List<TrackMessage> contents;

  @XmlAttribute(name = "subscribe")
  private Boolean subscribe;

  @XmlAttribute(name = "replace")
  private Boolean replace;

  @XmlAttribute(name = "files")
  private Boolean files;

  @XmlAttribute(name = "on")
  private TrackEvent on;

  public List<TrackField> getFields() {
    if (fields == null) {
      fields = new ArrayList<>();
    }
    return this.fields;
  }

  public List<TrackMessage> getMessages() {
    if (messages == null) {
      messages = new ArrayList<>();
    }
    return this.messages;
  }

  public List<TrackMessage> getContents() {
    if (contents == null) {
      contents = new ArrayList<>();
    }
    return this.contents;
  }

  public Boolean getSubscribe() {
    return subscribe;
  }

  public void setSubscribe(Boolean value) {
    this.subscribe = value;
  }

  public Boolean getReplace() {
    return replace;
  }

  public void setReplace(Boolean value) {
    this.replace = value;
  }

  public Boolean getFiles() {
    return files;
  }

  public void setFiles(Boolean value) {
    this.files = value;
  }

  public TrackEvent getOn() {
    if (on == null) {
      return TrackEvent.ALWAYS;
    } else {
      return on;
    }
  }

  public void setOn(TrackEvent value) {
    this.on = value;
  }

  public Track merge(Track other) {
    getFields().addAll(other.getFields());
    getMessages().addAll(other.getMessages());
    getContents().addAll(other.getContents());
    if (isTrue(other.replace)) {
      subscribe = other.subscribe;
    }
    return this;
  }

  public Track copyFor(Entity base) {
    Track track = new Track();
    track.merge(this);
    return track;
  }

  public JavaAnnotation toJavaAnnotation() {
    var annon = new JavaAnnotation("com.springforge.db.annotations.Track");

    if (on != null) annon.param("on", "{0:m}", "com.springforge.db.annotations.TrackEvent." + on);

    annon.param("fields", getFields(), TrackField::toJavaAnnotation);
    annon.param("messages", getMessages(), TrackMessage::toJavaAnnotation);
    annon.param("contents", getContents(), TrackMessage::toJavaAnnotation);

    if (isTrue(subscribe)) annon.param("subscribe", "true");
    if (isTrue(files)) annon.param("files", "true");

    return annon;
  }
}
// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\TrackEvent.java
package com.springforge.codegen.code.entity.model;

import jakarta.xml.bind.annotation.XmlEnum;

@XmlEnum
public enum TrackEvent {
  ALWAYS,

  CREATE,

  UPDATE;

  public String value() {
    return name();
  }

  public static TrackEvent fromValue(String v) {
    return valueOf(v);
  }
}
// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\TrackField.java
package com.springforge.codegen.code.entity.model;

import static com.springforge.codegen.code.entity.model.Utils.*;

import com.springforge.codegen.code.JavaAnnotation;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlType;

@XmlType
public class TrackField {

  @XmlAttribute(name = "name", required = true)
  private String name;

  @XmlAttribute(name = "if")
  private String condition;

  @XmlAttribute(name = "on")
  private TrackEvent on;

  public String getName() {
    return name;
  }

  public void setName(String value) {
    this.name = value;
  }

  public String getCondition() {
    return condition;
  }

  public TrackEvent getOn() {
    return on;
  }

  public void setOn(TrackEvent value) {
    this.on = value;
  }

  public JavaAnnotation toJavaAnnotation() {
    JavaAnnotation a =
            new JavaAnnotation("com.springforge.db.annotations.TrackField").param("name", "{0:s}", name);

    if (notBlank(condition)) a.param("condition", "{0:s}", condition);
    if (on != null) a.param("on", "{0:m}", "com.springforge.db.annotations.TrackEvent." + on);

    return a;
  }
}
// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\TrackMessage.java
package com.springforge.codegen.code.entity.model;

import static com.springforge.codegen.code.entity.model.Utils.*;

import com.springforge.codegen.code.JavaAnnotation;
import com.springforge.codegen.code.JavaCode;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlType;
import jakarta.xml.bind.annotation.XmlValue;

@XmlType
public class TrackMessage {

  @XmlValue private String value;

  @XmlAttribute(name = "if", required = true)
  private String condition;

  @XmlAttribute(name = "on")
  private TrackEvent on;

  @XmlAttribute(name = "tag")
  private TrackTag tag;

  @XmlAttribute(name = "fields")
  private String fields;

  public String getValue() {
    return value;
  }

  public void setValue(String value) {
    this.value = value;
  }

  public String getCondition() {
    return condition;
  }

  public void setCondition(String condition) {
    this.condition = condition;
  }

  public TrackEvent getOn() {
    if (on == null) {
      return TrackEvent.ALWAYS;
    } else {
      return on;
    }
  }

  public void setOn(TrackEvent value) {
    this.on = value;
  }

  public TrackTag getTag() {
    return tag;
  }

  public void setTag(TrackTag value) {
    this.tag = value;
  }

  public String getFields() {
    return fields;
  }

  public void setFields(String value) {
    this.fields = value;
  }

  public JavaAnnotation toJavaAnnotation() {
    var annon =
            new JavaAnnotation("com.springforge.db.annotations.TrackMessage")
                    .param("message", "{0:s}", value)
                    .param("condition", "{0:s}", condition);

    if (tag != null) annon.param("tag", "{0:s}", tag.value());
    if (on != null) {
      annon.param("on", "{0:m}", "com.springforge.db.annotations.TrackEvent." + on);
    }

    annon.param("fields", list(fields), s -> new JavaCode("{0:s}", s));

    return annon;
  }
}
// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\TrackTag.java
package com.springforge.codegen.code.entity.model;

import jakarta.xml.bind.annotation.XmlEnum;
import jakarta.xml.bind.annotation.XmlEnumValue;

@XmlEnum
public enum TrackTag {
  @XmlEnumValue("success")
  SUCCESS("success"),

  @XmlEnumValue("warning")
  WARNING("warning"),

  @XmlEnumValue("important")
  IMPORTANT("important"),

  @XmlEnumValue("info")
  INFO("info");

  private final String value;

  TrackTag(String v) {
    value = v;
  }

  public String value() {
    return value;
  }

  public static TrackTag fromValue(String v) {
    for (TrackTag c : TrackTag.values()) {
      if (c.value.equals(v)) {
        return c;
      }
    }
    throw new IllegalArgumentException(v);
  }
}
// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\UniqueConstraint.java

package com.springforge.codegen.code.entity.model;

import static com.springforge.codegen.code.entity.model.Utils.*;

import com.springforge.codegen.code.JavaAnnotation;
import com.springforge.codegen.code.JavaCode;
import jakarta.xml.bind.annotation.XmlType;

@XmlType
public class UniqueConstraint extends Index {

  @Override
  public JavaAnnotation toJavaAnnotation(Entity entity) {
    JavaAnnotation annotation = new JavaAnnotation("jakarta.persistence.UniqueConstraint");
    if (notBlank(getName())) {
      annotation.param("name", "{0:s}", getName());
    }
    annotation.param("columnNames", list(getColumnList(entity)), s -> new JavaCode("{0:s}", s));
    return annotation;
  }
}

// Fichier: C:\Users\K_ale\IdeaProjects\SpringForge\springforge-codegen\src\main\java\com\springforge\codegen\code\entity\model\Utils.java

package com.springforge.codegen.code.entity.model;

import com.springforge.common.ObjectUtils;
import com.springforge.common.StringUtils;
import com.springforge.codegen.code.JavaCodeUtils;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

interface Utils {

  static boolean isBlank(String value) {
    return StringUtils.isBlank(value);
  }

  static boolean notBlank(String value) {
    return StringUtils.notBlank(value);
  }

  static boolean isEmpty(Object value) {
    return ObjectUtils.isEmpty(value);
  }

  static boolean notEmpty(Object value) {
    return !isEmpty(value);
  }

  static boolean isTrue(Boolean value) {
    return Boolean.TRUE.equals(value);
  }

  static boolean isFalse(Boolean value) {
    return Boolean.FALSE.equals(value);
  }

  static boolean notTrue(Boolean value) {
    return !isTrue(value);
  }

  static boolean notFalse(Boolean value) {
    return !isFalse(value);
  }

  static Stream<String> stream(String list) {
    return isBlank(list) ? Stream.empty() : Stream.of(list.split(",")).map(String::trim);
  }

  static List<String> list(String list) {
    return stream(list).collect(Collectors.toList());
  }

  static String methodName(String prefix, String field) {
    return JavaCodeUtils.methodName(prefix, field);
  }

  static String getterName(String name) {
    return JavaCodeUtils.getterName(name);
  }

  static String setterName(String name) {
    return JavaCodeUtils.setterName(name);
  }
}
